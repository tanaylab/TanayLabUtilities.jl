var documenterSearchIndex = {"docs":
[{"location":"parallel_storage.html#Parallel-Storage","page":"Parallel Storage","title":"Parallel Storage","text":"","category":"section"},{"location":"parallel_storage.html","page":"Parallel Storage","title":"Parallel Storage","text":"TanayLabUtilities.ParallelStorage\nTanayLabUtilities.ParallelStorage.ReusableStorage\nTanayLabUtilities.ParallelStorage.get_reusable!\nTanayLabUtilities.ParallelStorage.put_reusable!\nTanayLabUtilities.ParallelStorage.with_reusable","category":"page"},{"location":"parallel_storage.html#TanayLabUtilities.ParallelStorage","page":"Parallel Storage","title":"TanayLabUtilities.ParallelStorage","text":"Allow reusing large data between parallel tasks.\n\nUsing task local storage will re-allocate and re-initialize this data for each iteration, which is slow, and overwork the garbage collector. Using thread local storage is no longer safe because Julia has moved away from \"sticky\" threads (that is, a task may migrate between threads); if naively implemented, it also create an instance per thread regardless whether it is actually used. The ReusableStorage allows allocating the minimal number of instances, reusing them in multiple tasks, and automates resetting the data each time it is used by a new task (if needed).\n\n\n\n\n\n","category":"module"},{"location":"parallel_storage.html#TanayLabUtilities.ParallelStorage.ReusableStorage","page":"Parallel Storage","title":"TanayLabUtilities.ParallelStorage.ReusableStorage","text":"ReusableStorage(create::Function)::ReusableStorage\n\nImplement resuable storage for parallel computations. This allocates and reuses the minimal number of instances of some data for (re)use by parallel tasks. The create function should return a new instance of the data. If a previous task has used the data, we will reset it to bring it back it to its initial state.\n\nnote: Note\nThe create and reset functions must be thread safe. We intentionally do not perform them while holding the global lock to maximize performance.\n\nmutable struct ExampleStorage\n    is_clean::Bool\nend\n\nfunction reset(storage::ExampleStorage)::Nothing\n    @assert !storage.is_clean\n    storage.is_clean = true\n    return nothing\nend\n\nreusable_storage = ReusableStorage(reset) do\n    return ExampleStorage(true)\nend\n\nfirst = nothing\nsecond = nothing\n\nwith_reusable(reusable_storage) do storage_1\n    @assert storage_1.is_clean\n    storage_1.is_clean = false\n    global first\n    first = storage_1\n\n    with_reusable(reusable_storage) do storage_2\n        @assert storage_2.is_clean\n        storage_2.is_clean = false\n        global second\n        second = storage_2\n        @assert second !== first\n    end\n\n    with_reusable(reusable_storage) do storage_3\n        @assert storage_3.is_clean\n        storage_3.is_clean = false\n        @assert storage_3 === second\n    end\nend\n\n@assert !first.is_clean\n@assert !second.is_clean\n\n# output\n\n\n\n\n\n\n","category":"type"},{"location":"parallel_storage.html#TanayLabUtilities.ParallelStorage.get_reusable!","page":"Parallel Storage","title":"TanayLabUtilities.ParallelStorage.get_reusable!","text":"get_reusable!(reusable_storage::ReusableStorage{T})::T where{T}\n\nGet a private instance of the data from the reusable storage. Will prefer to return an existing instance of the data, after being reset if used by a previous task. If all instances are currently being used by other tasks, will create a new instance instead.\n\n\n\n\n\n","category":"function"},{"location":"parallel_storage.html#TanayLabUtilities.ParallelStorage.put_reusable!","page":"Parallel Storage","title":"TanayLabUtilities.ParallelStorage.put_reusable!","text":"put_reusable!(reusable_storage::ReusableStorage{T}, data::T)::Nothing\n\nPut back data into the reusable_storage once a task is done with it. This will allow other tasks to reuse this data (after being reset).\n\n\n\n\n\n","category":"function"},{"location":"parallel_storage.html#TanayLabUtilities.ParallelStorage.with_reusable","page":"Parallel Storage","title":"TanayLabUtilities.ParallelStorage.with_reusable","text":"with_reusable(action::Function, reusable_storage::ReusableStorage)::Any\n\nInvoke the action function with data fetched from the reusable_storage. Returns whatever the action returns. This just pairs get_reusable! and put_reusable!, even in the presence of exceptions.\n\n\n\n\n\n","category":"function"},{"location":"parallel_storage.html#Index","page":"Parallel Storage","title":"Index","text":"","category":"section"},{"location":"parallel_storage.html","page":"Parallel Storage","title":"Parallel Storage","text":"Pages = [\"parallel_storage.md\"]","category":"page"},{"location":"brief.html#Brief","page":"Brief","title":"Brief","text":"","category":"section"},{"location":"brief.html","page":"Brief","title":"Brief","text":"TanayLabUtilities.Brief\nTanayLabUtilities.brief\nTanayLabUtilities.MAX_BRIEF_STRING\nTanayLabUtilities.percent","category":"page"},{"location":"brief.html#TanayLabUtilities.Brief","page":"Brief","title":"TanayLabUtilities.Brief","text":"Functions for generating a brief description of arbitrary data. Yes, this is what the builtin summary is expected to do. However, summary doesn't summarize arrays that well. As we don't want to override it for types we don't own, we default brief to call summary and can then override it for whatever types we feel is necessary. For your own types, provide an implementation for summary as that is the \"right thing to do\".\n\n\n\n\n\n","category":"module"},{"location":"brief.html#TanayLabUtilities.Brief.brief","page":"Brief","title":"TanayLabUtilities.Brief.brief","text":"brief(value::Any)::String\n\nProvide a brief description of a value. This is basically summary but modified for specific types (in particular, vectors and matrices) to give \"better\" results.\n\nbrief(1.0)\n\n# output\n\n\"1.0\"\n\nbrief(true)\n\n# output\n\n\"true\"\n\nbrief(:foo)\n\n# output\n\n\":foo\"\n\nbrief(nothing)\n\n# output\n\n\"nothing\"\n\nbrief(missing)\n\n# output\n\n\"missing\"\n\nbrief(undef)\n\n# output\n\n\"undef\"\n\nbrief((\"foo\", :bar))\n\n# output\n\n\"(\\\"foo\\\", :bar)\"\n\nbrief(\"foo\")\n\n# output\n\n\"\\\"foo\\\"\"\n\nbrief(\"foo \"^10)\n\n# output\n\n\"\\\"foo foo foo foo ...\\\" (40)\"\n\n@enum Foo Bar Baz\n\nbrief(Bar)\n\n# output\n\n\"Foo::Bar\"\n\nstruct Foo end\n\nbrief(Foo())\n\n# output\n\n\"Foo\"\n\n\n\n\n\n","category":"function"},{"location":"brief.html#TanayLabUtilities.Brief.MAX_BRIEF_STRING","page":"Brief","title":"TanayLabUtilities.Brief.MAX_BRIEF_STRING","text":"The maximal length of strings we show as-is in brief. We only show a prefix of longer strings (followed by their length).\n\n\n\n\n\n","category":"constant"},{"location":"brief.html#TanayLabUtilities.Brief.percent","page":"Brief","title":"TanayLabUtilities.Brief.percent","text":"percent(used::Real, out_of::Real)::String\n\nFormat a fraction of used amount out_of some total, as an integer percent value. Very small fractions are denoted as <1% and very large fractions are denoted as >99%. We use this to show the percent of true values in masks, and the percent of non-zero entries in sparse arrays.\n\npercent(0, 0)\n\n# output\n\n\"NA%\"\n\npercent(0, 1000)\n\n# output\n\n\"0%\"\n\npercent(9, 1000)\n\n# output\n\n\"<1%\"\n\npercent(10, 1000)\n\n# output\n\n\"1%\"\n\npercent(11, 1000)\n\n# output\n\n\"1%\"\n\npercent(990, 1000)\n\n# output\n\n\"99%\"\n\npercent(991, 1000)\n\n# output\n\n\">99%\"\n\npercent(1000, 1000)\n\n# output\n\n\"100%\"\n\n\n\n\n\n","category":"function"},{"location":"brief.html#Index","page":"Brief","title":"Index","text":"","category":"section"},{"location":"brief.html","page":"Brief","title":"Brief","text":"Pages = [\"brief.md\"]","category":"page"},{"location":"handlers.html#Handlers","page":"Handlers","title":"Handlers","text":"","category":"section"},{"location":"handlers.html","page":"Handlers","title":"Handlers","text":"TanayLabUtilities.Handlers\nTanayLabUtilities.Handlers.AbnormalHandler\nTanayLabUtilities.Handlers.handle_abnormal","category":"page"},{"location":"handlers.html#TanayLabUtilities.Handlers","page":"Handlers","title":"TanayLabUtilities.Handlers","text":"ma Functions for handling abnormal conditions.\n\n\n\n\n\n","category":"module"},{"location":"handlers.html#TanayLabUtilities.Handlers.AbnormalHandler","page":"Handlers","title":"TanayLabUtilities.Handlers.AbnormalHandler","text":"The action to take when encountering an \"abnormal\" (but recoverable) operation.\n\nValid values are:\n\nIgnoreHandler - ignore the issue and perform the recovery operation.\n\nWarnHandler - emit a warning using @warn and perform the recovery operation.\n\nErrorHandler - abort the program with an error message.\n\n\n\n\n\n","category":"type"},{"location":"handlers.html#TanayLabUtilities.Handlers.handle_abnormal","page":"Handlers","title":"TanayLabUtilities.Handlers.handle_abnormal","text":"handle_abnormal(message::Function, handler::AbnormalHandler)::Nothing\nhandle_abnormal(handler::AbnormalHandler, message::AbstractString)::Nothing\n\nCall this when encountering some abnormal, but recoverable, condition. Follow it by the recovery code (handle_abnormal(abnormal_handler, \"message\"); recovery... or handle_abnormal(abnormal_handler) do return \"...message...\" end; recovery...).\n\nThis will error if the handler is ErrorHandler, and abort the program with the message. If it is WarnHandler, it will just @warn and return. If it is IgnoreHandler it will just return.\n\nIf message is a function, it should return the actual message to error with.\n\nhandle_abnormal(IgnoreHandler, \"message\")\n\n# output\n\n\nhandle_abnormal(IgnoreHandler) do\n    @assert false\nend\n\n# output\n\n\nhandle_abnormal(ErrorHandler, \"message\")\n\n# output\n\nERROR: message\n\nhandle_abnormal(ErrorHandler) do\n    return \"message\"\nend\n\n# output\n\nERROR: message\n\nhandle_abnormal(WarnHandler, \"message\")\n\n# output\n\nâ”Œ Warning: message\nâ”” @ TanayLabUtilities.Handlers\n\nhandle_abnormal(WarnHandler) do\n    return \"message\"\nend\n\n# output\n\nâ”Œ Warning: message\nâ”” @ TanayLabUtilities.Handlers\n\n\n\n\n\n","category":"function"},{"location":"handlers.html#Index","page":"Handlers","title":"Index","text":"","category":"section"},{"location":"handlers.html","page":"Handlers","title":"Handlers","text":"Pages = [\"handlers.md\"]","category":"page"},{"location":"locks.html#Locks","page":"Locks","title":"Locks","text":"","category":"section"},{"location":"locks.html","page":"Locks","title":"Locks","text":"TanayLabUtilities.Locks\nTanayLabUtilities.Locks.ReentrantReadWriteLock","category":"page"},{"location":"locks.html#TanayLabUtilities.Locks","page":"Locks","title":"TanayLabUtilities.Locks","text":"Generic (reentrant) read-write locks.\n\nThese add functionality on top of ConcurrentUtils; specifically, they allow querying the status of the lock, and querying the status of the lock. We also provide explicit write_* and read_* functions instead of relying on lock to be write_lock. That is, ReentrantReadWriteLock is not an AbstractLock.\n\nread_write_lock = ReentrantReadWriteLock()\n\n@assert !has_write_lock(read_write_lock)\n@assert !has_read_lock(read_write_lock)\n\nwith_write_lock(read_write_lock, \"top_write\") do\n    @assert has_write_lock(read_write_lock)\n    @assert has_read_lock(read_write_lock)\n\n    with_write_lock(read_write_lock, \"nested_write\") do\n        @assert has_write_lock(read_write_lock)\n        @assert has_read_lock(read_write_lock)\n    end\n\n    with_read_lock(read_write_lock, \"nested_read\") do\n        @assert has_write_lock(read_write_lock)\n        @assert has_read_lock(read_write_lock)\n    end\nend\n\n@assert !has_write_lock(read_write_lock)\n@assert !has_read_lock(read_write_lock)\n\n# output\n\n\nread_write_lock = ReentrantReadWriteLock()\n\n@assert !has_write_lock(read_write_lock)\n@assert !has_read_lock(read_write_lock)\n\nwith_read_lock(read_write_lock, \"top_read\") do\n    @assert !has_write_lock(read_write_lock)\n    @assert has_read_lock(read_write_lock)\n\n    with_read_lock(read_write_lock, \"nested_read\") do\n        @assert !has_write_lock(read_write_lock)\n        @assert has_read_lock(read_write_lock)\n    end\nend\n\n@assert !has_write_lock(read_write_lock)\n@assert !has_read_lock(read_write_lock)\n\n# output\n\n\nread_write_lock = ReentrantReadWriteLock()\n\n@assert !has_write_lock(read_write_lock)\n@assert !has_read_lock(read_write_lock)\n\nwith_read_lock(read_write_lock, \"top_read\") do\n    @assert !has_write_lock(read_write_lock)\n    @assert has_read_lock(read_write_lock)\n\n    with_write_lock(read_write_lock, \"nested_write\") do\n        @assert false\n    end\nend\n\n# output\n\nERROR: trying to obtain write lock for: nested_write\nwhile holding read lock:\n\n\n\n\n\n","category":"module"},{"location":"locks.html#TanayLabUtilities.Locks.ReentrantReadWriteLock","page":"Locks","title":"TanayLabUtilities.Locks.ReentrantReadWriteLock","text":"struct ReentrantReadWriteLock <: AbstractLock ... end\n\nA read-write lock that supports nested calls. You can nest read locks, write locks, and read locks inside write locks. However, you can't nest write locks in read locks.\n\n\n\n\n\n","category":"type"},{"location":"locks.html#Write-Lock","page":"Locks","title":"Write Lock","text":"","category":"section"},{"location":"locks.html","page":"Locks","title":"Locks","text":"TanayLabUtilities.Locks.write_lock\nTanayLabUtilities.Locks.write_unlock\nTanayLabUtilities.Locks.with_write_lock\nTanayLabUtilities.Locks.has_write_lock","category":"page"},{"location":"locks.html#TanayLabUtilities.Locks.write_lock","page":"Locks","title":"TanayLabUtilities.Locks.write_lock","text":"write_lock(read_write_lock::ReentrantReadWriteLock, what::Any...)::Nothing\n\nObtain a write lock. Each call must be matched by write_unlock. It is possible to nest write_lock/write_unlock call pairs.\n\nWhen a task has a write lock, no other task can have any lock.\n\nThe log messages includes what is being locked.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#TanayLabUtilities.Locks.write_unlock","page":"Locks","title":"TanayLabUtilities.Locks.write_unlock","text":"write_unlock(read_write_lock::ReentrantReadWriteLock, what::Any)::Nothing\n\nRelease a write lock. Each call must matched a call to write_lock. It is possible to nest write_lock/write_unlock call pairs.\n\nThe log messages includes what is being unlocked.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#TanayLabUtilities.Locks.with_write_lock","page":"Locks","title":"TanayLabUtilities.Locks.with_write_lock","text":"with_write_lock(action::Function, read_write_lock::ReentrantReadWriteLock, what::Any...)::Any\n\nPerform an action while holding a write_lock for the read_write_lock, return its result and write_unlock.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#TanayLabUtilities.Locks.has_write_lock","page":"Locks","title":"TanayLabUtilities.Locks.has_write_lock","text":"has_write_lock(read_write_lock::ReentrantReadWriteLock)::Bool\n\nReturn whether the current task has the write lock.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#Read-Locks","page":"Locks","title":"Read Locks","text":"","category":"section"},{"location":"locks.html","page":"Locks","title":"Locks","text":"TanayLabUtilities.Locks.read_lock\nTanayLabUtilities.Locks.read_unlock\nTanayLabUtilities.Locks.with_read_lock\nTanayLabUtilities.Locks.has_read_lock","category":"page"},{"location":"locks.html#TanayLabUtilities.Locks.read_lock","page":"Locks","title":"TanayLabUtilities.Locks.read_lock","text":"read_lock(read_write_lock::ReentrantReadWriteLock, what::Any...)::Nothing\n\nObtain a read lock. Each call must be matched by read_unlock. It is possible to nest read_lock/read_unlock call pairs, even inside write_lock/write_unlock pair(s); however, you can't nest write_lock/write_unlock inside a read_lock/read_unlock pair.\n\nWhen a task has a read lock, no other task can have a write lock, but other tasks may also have a read lock.\n\nThe log messages includes what is being locked.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#TanayLabUtilities.Locks.read_unlock","page":"Locks","title":"TanayLabUtilities.Locks.read_unlock","text":"read_unlock(read_write_lock::ReentrantReadWriteLock, what::Any...)::Nothing\n\nRelease a read lock. Each call must matched a call to read_lock. It is possible to nest read_lock/read_unlock call pairs.\n\nThe log messages includes what is being unlocked.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#TanayLabUtilities.Locks.with_read_lock","page":"Locks","title":"TanayLabUtilities.Locks.with_read_lock","text":"with_read_lock(action::Function, read_write_lock::ReentrantReadWriteLock, what::Any...)::Any\n\nPerform an action while holding a read_lock for the read_write_lock, return its result and read_unlock.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#TanayLabUtilities.Locks.has_read_lock","page":"Locks","title":"TanayLabUtilities.Locks.has_read_lock","text":"has_read_lock(read_write_lock::ReentrantReadWriteLock; read_only::Bool = false)::Bool\n\nReturn whether the current task has a read lock or the write lock. If read_only is set, then this will only return whether the current task as a read lock.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#Index","page":"Locks","title":"Index","text":"","category":"section"},{"location":"locks.html","page":"Locks","title":"Locks","text":"Pages = [\"locks.md\"]","category":"page"},{"location":"logger.html#Logger","page":"Logger","title":"Logger","text":"","category":"section"},{"location":"logger.html","page":"Logger","title":"Logger","text":"TanayLabUtilities.Logger\nTanayLabUtilities.Logger.setup_logger\nTanayLabUtilities.Logger.@logged","category":"page"},{"location":"logger.html#TanayLabUtilities.Logger","page":"Logger","title":"TanayLabUtilities.Logger","text":"Setup a global logger the way we like it.\n\n\n\n\n\n","category":"module"},{"location":"logger.html#TanayLabUtilities.Logger.setup_logger","page":"Logger","title":"TanayLabUtilities.Logger.setup_logger","text":"setup_logger(\n    io::IO = stderr;\n    [level::LogLevel = Warn,\n    show_time::Bool = true,\n    show_module::Bool = true,\n    show_location::Bool = false]\n)::Nothing\n\nSetup a global logger that will print into io.\n\nBy default, this will only print warnings. Note that increasing the log level will apply to everything. An alternative is to set up the environment variable JULIA_DEBUG to a comma-separated list of modules you wish to see the debug messages of.\n\nIf show_time, each message will be prefixed with a yyyy-dd-mm HH:MM:SS.sss timestamp prefix.\n\nIf show_module, each message will be prefixed with the name of the module emitting the message.\n\nIf show_location, each message will be prefixed with the file name and the line number emitting the message.\n\nnote: Note\nWhen multi-processing is used, a P<id>: process index is added to the log entries. When multi-threading is used, a T<id>: thread index is added to the log entries, as well as a K<id>: task index. To generate the latter, this stores a unique :task_id index in the task_local_storage. This is important since a task may migrate between threads.\n\n\n\n\n\n","category":"function"},{"location":"logger.html#TanayLabUtilities.Logger.@logged","page":"Logger","title":"TanayLabUtilities.Logger.@logged","text":"@logged function something(...)\n    return ...\nend\n\nAutomatically log (in Debug level) every invocation to the function. This will also log the values of the arguments. Emits a second log entry when the function returns, with the result (if any).\n\n@logged function bar()::Nothing\n    return nothing\nend\n\n@logged function foo(positional; named = 1 + 2)\n    bar()\n    return positional + named\nend\n\nusing Logging\nusing Test\nlogger = TestLogger(; min_level = Logging.Debug)\nwith_logger(logger) do\n    return foo(1; named = 2)\nend\nprint(join([\"$(record.level) : $(record.message)\" for record in logger.logs], \"\n\"))\n\n# output\n\nDebug : foo {\nDebug : - positional: 1\nDebug : - named: 2\nDebug : bar {\nDebug : bar return }\nDebug : foo return: 3 }\n\n\n\n\n\n","category":"macro"},{"location":"logger.html#Index","page":"Logger","title":"Index","text":"","category":"section"},{"location":"logger.html","page":"Logger","title":"Logger","text":"Pages = [\"logger.md\"]","category":"page"},{"location":"names.html#Text","page":"Text","title":"Text","text":"","category":"section"},{"location":"names.html","page":"Text","title":"Text","text":"TanayLabUtilities.Names\nTanayLabUtilities.Names.unique_name","category":"page"},{"location":"names.html#TanayLabUtilities.Names","page":"Text","title":"TanayLabUtilities.Names","text":"Functions for generating names.\n\n\n\n\n\n","category":"module"},{"location":"names.html#TanayLabUtilities.Names.unique_name","page":"Text","title":"TanayLabUtilities.Names.unique_name","text":"unique_name(prefix::AbstractString, separator::AbstractString = \"#\")::AbstractString\n\nUsing short, human-readable unique names for things is a great help when debugging. Normally one has to choose between using a human-provided short non-unique name, and an opaque object identifier, or a combination thereof. This function replaces the opaque object identifier with a short counter, which gives names that are both unique and short.\n\nThat is, this will return a unique name starting with the prefix and followed by the separator (by default, #), the process index (if using multiple processes), and an index (how many times this name was used in the process). For example, unique_name(\"foo\") will return foo for the first usage, foo#2 for the 2nd, etc. If using multiple processes, it will return foo, foo#1.2, etc.\n\nThat is, for code where the names are unique (e.g., a simple script or Jupyter notebook), this doesn't mess up the names. It only appends a suffix to the names if it is needed to disambiguate between multiple uses of the same name.\n\nTo help with tests, if the prefix contains !, we return it as-is, accepting it may not be unique.\n\nExample\n\nusing TanayLabUtilities.Names\n\nunique_name(\"foo\")\n\n# output\n\n\"foo\"\n\nSecond usage\n\nusing TanayLabUtilities.Names\n\nunique_name(\"foo\")\n\n# output\n\n\"foo#2\"\n\nForce not unique\n\nusing TanayLabUtilities.Names\n\nunique_name(\"foo!\")\n\n# output\n\n\"foo!\"\n\nSecond usage\n\nusing TanayLabUtilities.Names\n\nunique_name(\"foo!\")\n\n# output\n\n\"foo!\"\n\n\n\n\n\n","category":"function"},{"location":"names.html#Index","page":"Text","title":"Index","text":"","category":"section"},{"location":"names.html","page":"Text","title":"Text","text":"Pages = [\"names.md\"]","category":"page"},{"location":"index.html#TanayLabUtilities","page":"TanayLabUtilities","title":"TanayLabUtilities","text":"","category":"section"},{"location":"index.html","page":"TanayLabUtilities","title":"TanayLabUtilities","text":"TanayLabUtilities.TanayLabUtilities","category":"page"},{"location":"index.html#TanayLabUtilities.TanayLabUtilities","page":"TanayLabUtilities","title":"TanayLabUtilities.TanayLabUtilities","text":"Generic utilities used by the Julia code for the Tanay lab.\n\nThis is a somewhat arbitrary collection of \"generally useful\" functions, created on an as-needed bases. No claim is made for true universality or for suitability for a particular purpose.\n\nIf you write using TanayLabUtilities everything will be exported into your global namespaces. Since this is a collection of loosely related functions, you may prefer to write using TanayLabUtilities.SomethingSpecific instead, or just import the specific symbol(s) you need.\n\nThe included modules are:\n\n(Image: )\n\n\n\n\n\n","category":"module"},{"location":"index.html#Index","page":"TanayLabUtilities","title":"Index","text":"","category":"section"},{"location":"index.html","page":"TanayLabUtilities","title":"TanayLabUtilities","text":"","category":"page"},{"location":"documentation.html#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"TanayLabUtilities.Documentation\nTanayLabUtilities.Documentation.@documented\nTanayLabUtilities.Documentation.DEFAULT\nTanayLabUtilities.Documentation.function_default","category":"page"},{"location":"documentation.html#TanayLabUtilities.Documentation","page":"Documentation","title":"TanayLabUtilities.Documentation","text":"Enhanced documentation for functions. This allows using the default values of function parameters as the basis for default values of other function parameters.\n\n\n\n\n\n","category":"module"},{"location":"documentation.html#TanayLabUtilities.Documentation.@documented","page":"Documentation","title":"TanayLabUtilities.Documentation.@documented","text":"@documented function something(...)\n    return ...\nend\n\nEnhance the documentation of a function. This stashes the default value of named arguments. This allows expanding DEFAULT in the documentation string, which is especially useful if these defaults are computed, read from global constants, copied from other functions via function_default, etc.\n\n\"Foo, default x: $(DEFAULT.x), default y: $(DEFAULT.y).\"\n@documented function foo(x::Integer = 1; y::Integer = 2)::Integer\n    return x + y\nend\n\n@assert foo() == 3\n@assert foo(2) == 4\nprintln(repr(\"text/markdown\", @doc foo))\n\n# output\n\nFoo, default x: `1`, default y: `2`.\n\n\"Foo, default x: $(DEFAULT.x).\"\n@documented function foo()::Integer\n    return 1\nend\n\nprintln(repr(\"text/markdown\", @doc foo))\n\n# output\n\nERROR: no parameter (with default): x\nexists for the function: foo\n\n\"Foo, default x: $(DEFAULT.x), default y: $(DEFAULT.y).\"\nfunction foo(x::Integer = 1; y::Integer = 2)::Integer\n    return x + y\nend\n\nprintln(repr(\"text/markdown\", @doc foo))\n\n# output\n\nERROR: not a @documented function: foo\n\n\n\n\n\n","category":"macro"},{"location":"documentation.html#TanayLabUtilities.Documentation.DEFAULT","page":"Documentation","title":"TanayLabUtilities.Documentation.DEFAULT","text":"When using @documented, then $(DEFAULT.x) will be expanded with the default value of the parameter x. It is good practice to contain a description of the effects of each parameter somewhere in the documentation, and it is polite to also provide its default value. This can be done in either the signature line or in the text, or both. Using DEFAULT ensures that the correct value is used in the documentation.\n\n\n\n\n\n","category":"constant"},{"location":"documentation.html#TanayLabUtilities.Documentation.function_default","page":"Documentation","title":"TanayLabUtilities.Documentation.function_default","text":"function_default(func::Function, parameter::Symbol)::Contract\n\nAccess the default of a parameter of a function annotated by @documented.\n\n@documented function foo(x::Integer = 1)::Nothing\n    return nothing\nend\n\nprintln(function_default(foo, :x))\nprintln(function_default(foo, :y))\n\n# output\n\n1\nERROR: no parameter (with default): y\nexists for the function: foo\n\nfunction foo(x::Integer = 1)::Nothing\n    return nothing\nend\n\nfunction_default(foo, :x)\n\n# output\n\nERROR: not a @documented function: foo\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Index","page":"Documentation","title":"Index","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Pages = [\"documentation.md\"]","category":"page"},{"location":"types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"TanayLabUtilities.Types\nTanayLabUtilities.Types.Maybe\nTanayLabUtilities.Types.Unsure","category":"page"},{"location":"types.html#TanayLabUtilities.Types","page":"Types","title":"TanayLabUtilities.Types","text":"(Very) generic types.\n\nWe got sick and tired of writing Union{..., Nothing} everywhere. We therefore created this shorthand unions listed below and used them throughout the code. We're well aware there was a religious war of whether there should be a standard shorthand for this, vs. a standard shorthand for Union{..., Missing}, with everyone losing, that is, having to use the explicit Union notation everywhere.\n\nLooking at the answers here then Nothing means \"there is no value\" and Missing means \"there is a value, but we don't know what it is\" (Unknown might have been a better name).\n\nUnder this interpretation, Union{..., Nothing} has (almost) the same semantics as Haskell's Maybe, so that's what we called it (other languages call this Optional or Opt). It is used heavily in our (and a lot of other) Julia code. We also added Unsure as a shorthand for Union{..., Missing} for completeness, but we do not actually use it anywhere. We assume it is useful for Julia code dealing specifically with statistical analysis.\n\n\n\n\n\n","category":"module"},{"location":"types.html#TanayLabUtilities.Types.Maybe","page":"Types","title":"TanayLabUtilities.Types.Maybe","text":"Maybe{T} = Union{T, Nothing}\n\nThe type to use when maybe there is a value, maybe there isn't. This is exactly as if writing the explicit Union with Nothing but is shorter and more readable. This is extremely common.\n\n\n\n\n\n","category":"type"},{"location":"types.html#TanayLabUtilities.Types.Unsure","page":"Types","title":"TanayLabUtilities.Types.Unsure","text":"Unsure{T} = Union{T, Missing}\n\nThe type to use when maybe there always is a value, but sometimes we are not sure what it is. This is exactly as if writing the explicit Union with Missing but is shorter and more readable. This is only used in code dealing with statistics to represent missing (that is, unknown) data. It is only provided here for completeness.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"}]
}
