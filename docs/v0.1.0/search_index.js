var documenterSearchIndex = {"docs":
[{"location":"handlers.html#Handlers","page":"Handlers","title":"Handlers","text":"","category":"section"},{"location":"handlers.html","page":"Handlers","title":"Handlers","text":"TanayLabUtilities.Handlers\nTanayLabUtilities.Handlers.AbnormalHandler\nTanayLabUtilities.Handlers.handle_abnormal","category":"page"},{"location":"handlers.html#TanayLabUtilities.Handlers","page":"Handlers","title":"TanayLabUtilities.Handlers","text":"ma Functions for handling abnormal conditions.\n\n\n\n\n\n","category":"module"},{"location":"handlers.html#TanayLabUtilities.Handlers.AbnormalHandler","page":"Handlers","title":"TanayLabUtilities.Handlers.AbnormalHandler","text":"The action to take when encountering an \"abnormal\" (but recoverable) operation.\n\nValid values are:\n\nIgnoreHandler - ignore the issue and perform the recovery operation.\n\nWarnHandler - emit a warning using @warn and perform the recovery operation.\n\nErrorHandler - abort the program with an error message.\n\n\n\n\n\n","category":"type"},{"location":"handlers.html#TanayLabUtilities.Handlers.handle_abnormal","page":"Handlers","title":"TanayLabUtilities.Handlers.handle_abnormal","text":"handle_abnormal(message::Function, handler::AbnormalHandler)::Nothing\nhandle_abnormal(handler::AbnormalHandler, message::AbstractString)::Nothing\n\nCall this when encountering some abnormal, but recoverable, condition. Follow it by the recovery code (handle_abnormal(abnormal_handler, \"message\"); recovery... or handle_abnormal(abnormal_handler) do return \"...message...\" end; recovery...).\n\nThis will error if the handler is ErrorHandler, and abort the program with the message. If it is WarnHandler, it will just @warn and return. If it is IgnoreHandler it will just return.\n\nIf message is a function, it should return the actual message to error with.\n\nhandle_abnormal(IgnoreHandler, \"message\")\n\n# output\n\n\nhandle_abnormal(IgnoreHandler) do\n    @assert false\nend\n\n# output\n\n\nhandle_abnormal(ErrorHandler, \"message\")\n\n# output\n\nERROR: message\n\nhandle_abnormal(ErrorHandler) do\n    return \"message\"\nend\n\n# output\n\nERROR: message\n\nhandle_abnormal(WarnHandler, \"message\")\n\n# output\n\n┌ Warning: message\n└ @ TanayLabUtilities.Handlers\n\nhandle_abnormal(WarnHandler) do\n    return \"message\"\nend\n\n# output\n\n┌ Warning: message\n└ @ TanayLabUtilities.Handlers\n\n\n\n\n\n","category":"function"},{"location":"handlers.html#Index","page":"Handlers","title":"Index","text":"","category":"section"},{"location":"handlers.html","page":"Handlers","title":"Handlers","text":"Pages = [\"handlers.md\"]","category":"page"},{"location":"downsample.html#Downsample","page":"Downsample","title":"Downsample","text":"","category":"section"},{"location":"downsample.html","page":"Downsample","title":"Downsample","text":"TanayLabUtilities.Downsample\nTanayLabUtilities.Downsample.downsample\nTanayLabUtilities.Downsample.downsamples","category":"page"},{"location":"downsample.html#TanayLabUtilities.Downsample","page":"Downsample","title":"TanayLabUtilities.Downsample","text":"Downsampling of data. The idea is that you have a vector containing a total of some (large) K counts of samples with values 1..N drawn from a multinomial distribution (with different probabilities for getting each of the 1..N values). Generate a vector with a total of some (smaller) k samples. This is typically done to a set of vectors, typically to all columns of a matrix (each with its own K(j)), to get a set of vectors with the same k.\n\nThis is useful for meaningfully comparing the vectors (for example, computing correlations between them). Without downsampling, distance measures between such vectors are biases by the sampling depth K. For example, correlations with deeper (higher total samples) vectors will tend to be higher.\n\nDownsampling discards data so we'd like the target k to be as large as possible. Typically this isn't the minimal K(j) to avoid a few shallow sampled vectors from ruining the quality of the results; we accept that a small fraction of the vectors will keep their original K(j) samples when this is less than the chosen k.\n\n\n\n\n\n","category":"module"},{"location":"downsample.html#TanayLabUtilities.Downsample.downsample","page":"Downsample","title":"TanayLabUtilities.Downsample.downsample","text":"downsample(\n    vector::AbstractVector{<:Integer},\n    samples::Integer;\n    rng::AbstractRNG = default_rng(),\n    output::Maybe{AbstractVector} = nothing,\n)::AbstractVector\n\ndownsample(\n    matrix::AbstractMatrix{<:Integer},\n    samples::Integer;\n    dims::Integer,\n    rng::AbstractRNG = default_rng(),\n    output::Maybe{AbstractMatrix} = nothing,\n)::AbstractMatrix\n\nGiven a vector of integer non-negative data values, return a new vector such that the sum of entries in it is samples. Think of the original vector as containing a number of marbles in each entry. We randomly pick samples marbles from this vector; each time we pick a marble we take it out of the original vector and move it to the same position in the result.\n\nIf the sum of the entries of a vector is less than samples, it is copied to the output. If output is not specified, it is allocated automatically using the same element type as the input.\n\nWhen downsampling a matrix, then dims must be specified to be 1/Rows to downsample all the rows in each column or 2/Columns to downsample all the columns in each row (that is, the sum with the same dims will give the number of samples in each vector).\n\nusing Test\n\n# Columns\n\ndata = rand(1:100, 10, 5)\nsamples_per_column = vec(sum(data; dims = 1))\n\nfor samples in (100, 250, 500, 750, 1000)\n    downsampled = downsample(data, samples; dims = 1)\n    downsamples_per_column = vec(sum(downsampled; dims = 1))\n    @test all(downsamples_per_column .== min.(samples_per_column, samples))\n    too_small_mask = samples_per_column .<= samples\n    @test all(downsampled[:, too_small_mask] .== data[:, too_small_mask])\nend\n\n# Rows\n\ndata = transpose(data)\nsamples_per_row = samples_per_column\n\nfor samples in (100, 250, 500, 750, 1000)\n    downsampled = downsample(data, samples; dims = 2)\n    downsamples_per_row = vec(sum(downsampled; dims = 2))\n    @test all(downsamples_per_row .== min.(samples_per_row, samples))\n    too_small_mask = samples_per_row .<= samples\n    @test all(downsampled[too_small_mask, :] .== data[too_small_mask, :])\nend\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"downsample.html#TanayLabUtilities.Downsample.downsamples","page":"Downsample","title":"TanayLabUtilities.Downsample.downsamples","text":"downsamples(\n    samples_per_vector::AbstractVector{<:Integer};\n    min_downsamples::Integer = ```750```,\n    min_downsamples_quantile::AbstractFloat = ```0.05```,\n    max_downsamples_quantile::AbstractFloat = ```0.5```,\n)::Integer\n\nWhen downsampling multiple vectors (the amount of data in each available in samples_per_vector), we need to pick a \"reasonable\" number of samples to downsample to. We have conflicting requirements, so this is a compromise. First, we want most vectors to have at least the target number of samples, so we start with the min_downsamples_quantile of the samples_per_vector. Second, we also want to have at least min_downsamples to ensure we don't throw away too much data even if many vectors are sparse, so we increase the target to this value. Finally, we don't want a target which is too big for too many vectors, so so we reduce the result to the max_downsamples_quantile of the samples_per_vector.\n\nnote: Note\nThe defaults (especially min_downsamples) were chosen to fit our needs (downsampling UMIs of sc-RNA-seq data). You will need to tweak them when using this for other purposes.\n\ndownsamples([100, 500, 1000])\n\n# output\n\n500\n\n\n\n\n\n","category":"function"},{"location":"downsample.html#Index","page":"Downsample","title":"Index","text":"","category":"section"},{"location":"downsample.html","page":"Downsample","title":"Downsample","text":"Pages = [\"downsample.md\"]","category":"page"},{"location":"unique_names.html#Unique-Names","page":"Unique Names","title":"Unique Names","text":"","category":"section"},{"location":"unique_names.html","page":"Unique Names","title":"Unique Names","text":"TanayLabUtilities.UniqueNames\nTanayLabUtilities.UniqueNames.unique_name","category":"page"},{"location":"unique_names.html#TanayLabUtilities.UniqueNames","page":"Unique Names","title":"TanayLabUtilities.UniqueNames","text":"Functions for generating names.\n\n\n\n\n\n","category":"module"},{"location":"unique_names.html#TanayLabUtilities.UniqueNames.unique_name","page":"Unique Names","title":"TanayLabUtilities.UniqueNames.unique_name","text":"unique_name(prefix::AbstractString, separator::AbstractString = \"#\")::AbstractString\n\nUsing short, human-readable unique names for things is a great help when debugging. Normally one has to choose between using a human-provided short non-unique name, and an opaque object identifier, or a combination thereof. This function replaces the opaque object identifier with a short counter, which gives names that are both unique and short.\n\nThat is, this will return a unique name starting with the prefix and followed by the separator (by default, #), the process index (if using multiple processes), and an index (how many times this name was used in the process). For example, unique_name(\"foo\") will return foo for the first usage, foo#2 for the 2nd, etc. If using multiple processes, it will return foo, foo#1.2, etc.\n\nThat is, for code where the names are unique (e.g., a simple script or Jupyter notebook), this doesn't mess up the names. It only appends a suffix to the names if it is needed to disambiguate between multiple uses of the same name.\n\nTo help with tests, if the prefix contains !, we return it as-is, accepting it may not be unique.\n\nExample\n\nusing TanayLabUtilities.UniqueNames\n\nunique_name(\"foo\")\n\n# output\n\n\"foo\"\n\nSecond usage\n\nusing TanayLabUtilities.UniqueNames\n\nunique_name(\"foo\")\n\n# output\n\n\"foo#2\"\n\nForce not unique\n\nusing TanayLabUtilities.UniqueNames\n\nunique_name(\"foo!\")\n\n# output\n\n\"foo!\"\n\nSecond usage\n\nusing TanayLabUtilities.UniqueNames\n\nunique_name(\"foo!\")\n\n# output\n\n\"foo!\"\n\n\n\n\n\n","category":"function"},{"location":"unique_names.html#Index","page":"Unique Names","title":"Index","text":"","category":"section"},{"location":"unique_names.html","page":"Unique Names","title":"Unique Names","text":"Pages = [\"unique_names.md\"]","category":"page"},{"location":"global_weak_cache.html#Global-Weak-Cache","page":"Global Weak Cache","title":"Global Weak Cache","text":"","category":"section"},{"location":"global_weak_cache.html","page":"Global Weak Cache","title":"Global Weak Cache","text":"TanayLabUtilities.GlobalWeakCache\nTanayLabUtilities.GlobalWeakCache.get_through_global_weak_cache","category":"page"},{"location":"global_weak_cache.html#TanayLabUtilities.GlobalWeakCache","page":"Global Weak Cache","title":"TanayLabUtilities.GlobalWeakCache","text":"Cache big expensive objects (that consume a lot of OS resources).\n\n\n\n\n\n","category":"module"},{"location":"global_weak_cache.html#TanayLabUtilities.GlobalWeakCache.get_through_global_weak_cache","page":"Global Weak Cache","title":"TanayLabUtilities.GlobalWeakCache.get_through_global_weak_cache","text":"get_through_global_weak_cache(getter::Function, key::Any)::Any\n\nGiven some unique key, fetch the associated object from the global cache (if it is there) or invoke the getter to obtain it (and cache it for future reference). As a convenience, the getter is passed the key. If purge is set, then any existing value is ignored and is replaced by the result of the getter.\n\nThere's a singleton GLOBAL_CACHE and all accesses are protected by a single GLOBAL_LOCK, so while this is thread-safe, it does not support parallelism. It is meant for heavy operations such as opening files etc., not for memoizing functions results for performance.\n\nThe cache holds weak references to the objects, so they are let go if there remain no active references to them (outside the cache).\n\n```jldoctest using Test\n\nfirst = getthroughglobalweakcache(:test) do _     return [1] end @test first == [1] @test first === getthroughglobalweakcache(:test) do _     @assert false end\n\nsecond = getthroughglobalweakcache(:test; purge = true) do _     return [2] end @assert second == [2]\n\nfirst = second = nothing gc() third = getthroughglobalweakcache(:test) do _     return [3] end @assert third == [3]\n\nprintln(\"OK\")\n\noutput\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"global_weak_cache.html#Index","page":"Global Weak Cache","title":"Index","text":"","category":"section"},{"location":"global_weak_cache.html","page":"Global Weak Cache","title":"Global Weak Cache","text":"Pages = [\"global_weak_cache.md\"]","category":"page"},{"location":"parallel_storage.html#Parallel-Storage","page":"Parallel Storage","title":"Parallel Storage","text":"","category":"section"},{"location":"parallel_storage.html","page":"Parallel Storage","title":"Parallel Storage","text":"TanayLabUtilities.ParallelStorage\nTanayLabUtilities.ParallelStorage.ReusableStorage\nTanayLabUtilities.ParallelStorage.get_reusable!\nTanayLabUtilities.ParallelStorage.put_reusable!\nTanayLabUtilities.ParallelStorage.with_reusable","category":"page"},{"location":"parallel_storage.html#TanayLabUtilities.ParallelStorage","page":"Parallel Storage","title":"TanayLabUtilities.ParallelStorage","text":"Allow reusing large data between parallel tasks. Using task local storage will re-allocate and re-initialize this data for each iteration, which is slow, and overwork the garbage collector. Using thread local storage is no longer safe because Julia has moved away from \"sticky\" threads (that is, a task may migrate between threads); if naively implemented, it also create an instance per thread regardless whether it is actually used. The ReusableStorage allows allocating the minimal number of instances, reusing them in multiple tasks, and automates resetting the data each time it is used by a new task (if needed).\n\n\n\n\n\n","category":"module"},{"location":"parallel_storage.html#TanayLabUtilities.ParallelStorage.ReusableStorage","page":"Parallel Storage","title":"TanayLabUtilities.ParallelStorage.ReusableStorage","text":"ReusableStorage(create::Function)::ReusableStorage\n\nImplement resuable storage for parallel computations. This allocates and reuses the minimal number of instances of some data for (re)use by parallel tasks. The create function should return a new instance of the data. If a previous task has used the data, we will reset it to bring it back it to its initial state.\n\nnote: Note\nThe create and reset functions must be thread safe. We intentionally do not perform them while holding the global lock to maximize performance.\n\nmutable struct ExampleStorage\n    is_clean::Bool\nend\n\nfunction reset(storage::ExampleStorage)::Nothing\n    @assert !storage.is_clean\n    storage.is_clean = true\n    return nothing\nend\n\nreusable_storage = ReusableStorage(reset) do\n    return ExampleStorage(true)\nend\n\nfirst = nothing\nsecond = nothing\n\nwith_reusable(reusable_storage) do storage_1\n    @assert storage_1.is_clean\n    storage_1.is_clean = false\n    global first\n    first = storage_1\n\n    with_reusable(reusable_storage) do storage_2\n        @assert storage_2.is_clean\n        storage_2.is_clean = false\n        global second\n        second = storage_2\n        @assert second !== first\n    end\n\n    with_reusable(reusable_storage) do storage_3\n        @assert storage_3.is_clean\n        storage_3.is_clean = false\n        @assert storage_3 === second\n    end\nend\n\n@assert !first.is_clean\n@assert !second.is_clean\n\n# output\n\n\n\n\n\n\n","category":"type"},{"location":"parallel_storage.html#TanayLabUtilities.ParallelStorage.get_reusable!","page":"Parallel Storage","title":"TanayLabUtilities.ParallelStorage.get_reusable!","text":"get_reusable!(reusable_storage::ReusableStorage{T})::T where{T}\n\nGet a private instance of the data from the reusable storage. Will prefer to return an existing instance of the data, after being reset if used by a previous task. If all instances are currently being used by other tasks, will create a new instance instead.\n\n\n\n\n\n","category":"function"},{"location":"parallel_storage.html#TanayLabUtilities.ParallelStorage.put_reusable!","page":"Parallel Storage","title":"TanayLabUtilities.ParallelStorage.put_reusable!","text":"put_reusable!(reusable_storage::ReusableStorage{T}, data::T)::Nothing\n\nPut back data into the reusable_storage once a task is done with it. This will allow other tasks to reuse this data (after being reset).\n\n\n\n\n\n","category":"function"},{"location":"parallel_storage.html#TanayLabUtilities.ParallelStorage.with_reusable","page":"Parallel Storage","title":"TanayLabUtilities.ParallelStorage.with_reusable","text":"with_reusable(action::Function, reusable_storage::ReusableStorage)::Any\n\nInvoke the action function with data fetched from the reusable_storage. Returns whatever the action returns. This just pairs get_reusable! and put_reusable!, even in the presence of exceptions.\n\n\n\n\n\n","category":"function"},{"location":"parallel_storage.html#Index","page":"Parallel Storage","title":"Index","text":"","category":"section"},{"location":"parallel_storage.html","page":"Parallel Storage","title":"Parallel Storage","text":"Pages = [\"parallel_storage.md\"]","category":"page"},{"location":"matrix_layouts.html#Matrix-layouts","page":"Matrix layouts","title":"Matrix layouts","text":"","category":"section"},{"location":"matrix_layouts.html","page":"Matrix layouts","title":"Matrix layouts","text":"TanayLabUtilities.MatrixLayouts\nTanayLabUtilities.MatrixLayouts.Rows\nTanayLabUtilities.MatrixLayouts.Columns\nTanayLabUtilities.MatrixLayouts.axis_name\nTanayLabUtilities.MatrixLayouts.major_axis\nTanayLabUtilities.MatrixLayouts.require_major_axis\nTanayLabUtilities.MatrixLayouts.minor_axis\nTanayLabUtilities.MatrixLayouts.require_minor_axis\nTanayLabUtilities.MatrixLayouts.other_axis\nTanayLabUtilities.MatrixLayouts.relayout!\nTanayLabUtilities.MatrixLayouts.relayout\nTanayLabUtilities.MatrixLayouts.transposer\nTanayLabUtilities.MatrixLayouts.@assert_vector\nTanayLabUtilities.MatrixLayouts.@assert_matrix\nTanayLabUtilities.MatrixLayouts.GLOBAL_INEFFICIENT_ACTION_HANDLER","category":"page"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts","text":"Matrix data that has a clear layout, that is, a major_axis, regardless of whether it is dense or sparse.\n\nThat is, for Columns-major data, the values of each column are laid out consecutively in memory (each column is a single contiguous vector), so any operation that works on whole columns will be fast (e.g., summing the value of each column). In contrast, the values of each row are stored far apart from each other, so any operation that works on whole rows will be very slow in comparison (e.g., summing the value of each row).\n\nFor Rows-major data, the values of each row are laid out consecutively in memory (each row is a single contiguous vector). In contrast, the values of each column are stored far apart from each other. In this case, summing columns would be slow, and summing rows would be fast.\n\nThis is much simpler than the ArrayLayouts module which attempts to fully describe the layout of N-dimensional arrays, a much more ambitious goal which is an overkill for our needs.\n\nnote: Note\nThe \"default\" layout in Julia is column-major, which inherits this from matlab, which inherits this from FORTRAN, allegedly because this is more efficient for some linear algebra operations. In contrast, most system languages and Python numpy use row-major layout by default, because that's the sane layout (and generalizes better for tensors). At any rate, all systems work just fine with data of either memory layout; the key consideration is to keep track of the layout, and to apply operations \"with the grain\" rather than \"against the grain\" of the data.\n\n\n\n\n\n","category":"module"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.Rows","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.Rows","text":"A symbolic name for the rows axis. It is more readable to write, say, size(matrix, Rows), instead of size(matrix, 1).\n\n\n\n\n\n","category":"constant"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.Columns","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.Columns","text":"A symbolic name for the rows axis. It is more readable to write, say, size(matrix, Columns), instead of size(matrix, 2).\n\n\n\n\n\n","category":"constant"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.axis_name","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.axis_name","text":"axis_name(axis::Maybe{Integer})::String\n\nReturn the name of the axis (for messages).\n\nprintln(axis_name(nothing))\nprintln(axis_name(Rows))\nprintln(axis_name(Columns))\nprintln(axis_name(3))\n\n# output\n\nnothing\nRows\nColumns\nERROR: invalid matrix axis: 3\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.major_axis","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.major_axis","text":"major_axis(matrix::AbstractMatrix)::Maybe{Int8}\n\nReturn the index of the major axis of a matrix, that is, the axis one should keep fixed for an efficient inner loop accessing the matrix elements. If the matrix doesn't support any efficient access axis, returns nothing.\n\nusing Test\n\nbase = [0 1 2; 3 4 0]\n\n@test major_axis(base) == Columns\n\n# Slice\n\n@test major_axis(@view base[:, [1, 3, 2]]) == nothing\n\n# Named\n\nusing NamedArrays\n\n@test major_axis(NamedArray(base)) == Columns\n\n# Permuted\n\npermuted = PermutedDimsArray(base, (2, 1))\n@test major_axis(permuted) == Rows\n\nunpermuted = PermutedDimsArray(base, (1, 2))\n@test major_axis(unpermuted) == Columns\n\n# LinearAlgebra\n\ntransposed = transpose(base)\n@test major_axis(transposed) == Rows\n\nadjointed = adjoint(base)\n@test major_axis(adjointed) == Rows\n\n# Sparse\n\nusing SparseArrays\n\nsparse = SparseMatrixCSC(base)\n@test major_axis(sparse) == Columns\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.require_major_axis","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.require_major_axis","text":"require_major_axis(matrix::AbstractMatrix)::Int8\n\nSimilar to major_axis but will error if the matrix isn't in either row-major or column-major layout.\n\nusing Test\n\nbase = [0 1 2; 3 4 0]\n\n@test require_major_axis(base) == Columns\n\nrequire_major_axis(@view base[:, [1, 3, 2]])\n\n# output\n\nERROR: type: SubArray{Int64, 2, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false} is not in any-major layout\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.minor_axis","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.minor_axis","text":"minor_axis(matrix::AbstractMatrix)::Maybe{Int8}\n\nReturn the index of the minor axis of a matrix, that is, the axis one should vary for an efficient inner loop accessing the matrix elements. If the matrix doesn't support any efficient access axis, returns nothing.\n\nusing Test\n\nbase = [0 1 2; 3 4 0]\n\n@test minor_axis(base) == Rows\n\n# Slice\n\n@test minor_axis(@view base[:, [1, 3, 2]]) == nothing\n\n# Named\n\nusing NamedArrays\n\n@test minor_axis(NamedArray(base)) == Rows\n\n# Permuted\n\npermuted = PermutedDimsArray(base, (2, 1))\n@test minor_axis(permuted) == Columns\n\nunpermuted = PermutedDimsArray(base, (1, 2))\n@test minor_axis(unpermuted) == Rows\n\n# LinearAlgebra\n\ntransposed = transpose(base)\n@test minor_axis(transposed) == Columns\n\nadjointed = adjoint(base)\n@test minor_axis(adjointed) == Columns\n\n# Sparse\n\nusing SparseArrays\n\nsparse = SparseMatrixCSC(base)\n@test minor_axis(sparse) == Rows\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.require_minor_axis","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.require_minor_axis","text":"require_minor_axis(matrix::AbstractMatrix)::Int8\n\nSimilar to minor_axis but will error if the matrix isn't in either row-major or column-major layout.\n\nusing Test\n\nbase = [0 1 2; 3 4 0]\n\n@test require_minor_axis(base) == Rows\n\nrequire_minor_axis(@view base[:, [1, 3, 2]])\n\n# output\n\nERROR: type: SubArray{Int64, 2, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false} is not in any-major layout\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.other_axis","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.other_axis","text":"other_axis(axis::Maybe{Integer})::Maybe{Int8}\n\nReturn the other matrix axis (that is, convert between Rows and Columns). If given nothing returns nothing.\n\nusing Test\n\n@test other_axis(nothing) == nothing\n@test other_axis(Rows) == Columns\n@test other_axis(Columns) == Rows\n\nother_axis(3)\n\n# output\n\nERROR: invalid matrix axis: 3\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.relayout!","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.relayout!","text":"relayout!(destination::AbstractMatrix, source::AbstractMatrix)::AbstractMatrix\nrelayout!(destination::AbstractMatrix, source::NamedMatrix)::NamedMatrix\n\nReturn the same matrix data, but in the other memory layout.\n\nSuppose you have a column-major UMIs matrix, whose rows are cells, and columns are genes. Therefore, looping on the UMIs of a gene will be fast, but looping on the UMIs of a cell will be slow. A transpose (no !) of a matrix is fast; it creates a zero-copy wrapper of the matrix with flipped axes, so its rows will be genes and columns will be cells, but in row-major layout. Therefore, still, looping on the UMIs of a gene is fast, and looping on the UMIs of a cell is slow.\n\nIn contrast, transpose! (with a !) (or transposer) is slow; it creates a rearranged copy of the data, also returning a matrix whose rows are genes and columns are cells, but this time, in column-major layout. Therefore, in this case looping on the UMIs of a gene will be slow, and looping on the UMIs of a cell will be fast.\n\nnote: Note\nIt is almost always worthwhile to relayout! a matrix and then looping \"with the grain\" of the data, instead of skipping it and looping \"against the grain\" of the data. This is because (in Julia at least) the implementation of transpose! is optimized for the task, while the other operations typically don't provide any specific optimizations for working \"against the grain\" of the data. The benefits of a relayout! become more significant the more operations are done on the data in the loop.\n\nThe relayout! is essentially a zero-copy transpose of the slow transpose!. You end up with a matrix that appears to be the same as the original (rows are cells and columns are genes), but behaves differently - looping on the UMIs of a gene will be slow, and looping on the UMIs of a cell will be fast. In addition, relayout! will work for both sparse and dense matrices. If the source is a NamedMatrix, then the result will be a NamedMatrix with the same axes (zero-copy shared from the source). If destination is already a NamedMatrix, then its axes must match source.\n\nnote: Note\nThe caller is responsible for providing a sensible destination matrix (sparse for a sparse source, dense for a non-sparse source).\n\nusing Test\n\nusing LinearAlgebra\n\nsource = rand(3, 4)\ndestination = transpose(rand(4, 3))\n\nresult = relayout!(destination, source)\n@test result === destination\n@test brief(source) == \"3 x 4 x Float64 in Columns (Dense)\"\n@test brief(result) == \"3 x 4 x Float64 in Rows (Transpose, Dense)\"\n@test result == source\n\n# Named\n\nusing NamedArrays\n\nnamed_source = NamedArray(rand(3, 4))\ndestination = transpose(rand(4, 3))\nresult = relayout!(destination, named_source)\n@test parent(result) === destination\n@test brief(named_source) == \"3 x 4 x Float64 in Columns (Named, Dense)\"\n@test brief(result) == \"3 x 4 x Float64 in Rows (Named, Transpose, Dense)\"\n@test result == named_source\n\nsource = rand(3, 4)\nnamed_destination = NamedArray(transpose(rand(4, 3)))\nresult = relayout!(named_destination, source)\n@test result === named_destination\n@test brief(source) == \"3 x 4 x Float64 in Columns (Dense)\"\n@test brief(result) == \"3 x 4 x Float64 in Rows (Named, Transpose, Dense)\"\n@test result == source\n\nsource = rand(3, 4)\nnamed_destination = Transpose(NamedArray(rand(4, 3)))\nresult = relayout!(named_destination, source)\n@test result === named_destination\n@test brief(source) == \"3 x 4 x Float64 in Columns (Dense)\"\n@test brief(result) == \"3 x 4 x Float64 in Rows (Transpose, Named, Dense)\"\n@test result == source\n\nnamed_source = NamedArray(rand(3, 4))\nnamed_destination = NamedArray(transpose(rand(4, 3)))\nresult = relayout!(named_destination, named_source)\n@test result === named_destination\n@test brief(named_source) == \"3 x 4 x Float64 in Columns (Named, Dense)\"\n@test brief(result) == \"3 x 4 x Float64 in Rows (Named, Transpose, Dense)\"\n@test result == named_source\n\n# Permuted\n\nsource = rand(3, 4)\ndestination = PermutedDimsArray(rand(4, 3), (2,1))\nresult = relayout!(destination, source)\n@test result === destination\n@test brief(source) == \"3 x 4 x Float64 in Columns (Dense)\"\n@test brief(result) == \"3 x 4 x Float64 in Rows (Permute, Dense)\"\n@test result == source\n\nsource = rand(3, 4)\ndestination = PermutedDimsArray(adjoint(rand(4, 3)), (1,2))\nresult = relayout!(destination, source)\n@test result === destination\n@test brief(source) == \"3 x 4 x Float64 in Columns (Dense)\"\n@test brief(result) == \"3 x 4 x Float64 in Rows (!Permute, Adjoint, Dense)\"\n@test result == source\n\n# Sparse\n\nusing SparseArrays\n\nsource = SparseMatrixCSC([0.0 1.0 2.0; 3.0 4.0 0.0])\ndestination = transpose(SparseMatrixCSC([30.0 0.0; 0.0 40.0; 20.0 10.0]))\nresult = relayout!(destination, source)\n@test result === destination\n@test brief(source) == \"2 x 3 x Float64 in Columns (Sparse Int64 67%)\"\n@test brief(result) == \"2 x 3 x Float64 in Rows (Transpose, Sparse Int64 67%)\"\n@test result == source\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.relayout","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.relayout","text":"relayout(matrix::AbstractMatrix)::AbstractMatrix\nrelayout(matrix::NamedMatrix)::NamedMatrix\n\nSame as relayout! but allocates the destination matrix for you. Is equivalent to transpose(transposer(matrix)).\n\nbase = rand(3, 4)\n@assert relayout(base) == base\n@assert major_axis(relayout(base)) == minor_axis(base)\n\n# output\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.transposer","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.transposer","text":"transposer(matrix::AbstractMatrix)::AbstractMatrix\n\nReturn a transpose of a matrix, but instead of simply using a zero-copy wrapper, it actually rearranges the data. See relayout!.\n\nusing Test\n\n# Dense\n\nbase = rand(3, 4)\n@test transposer(base) == transpose(base)\n@test brief(base) == \"3 x 4 x Float64 in Columns (Dense)\"\n@test brief(transpose(base)) == \"4 x 3 x Float64 in Rows (Transpose, Dense)\"\n@test brief(transposer(base)) == \"4 x 3 x Float64 in Columns (Dense)\"\n\n# Named\n\nusing NamedArrays\n\nbase = NamedArray(rand(3, 4))\n@test transposer(base) == transpose(base)\n@test brief(base) == \"3 x 4 x Float64 in Columns (Named, Dense)\"\n@test brief(transpose(base)) == \"4 x 3 x Float64 in Rows (Named, Transpose, Dense)\"\n@test brief(transposer(base)) == \"4 x 3 x Float64 in Columns (Named, Dense)\"\n\n# Permuted\n\nbase = PermutedDimsArray(rand(3, 4), (2,1))\n@test transposer(base) == transpose(base)\n@test brief(base) == \"4 x 3 x Float64 in Rows (Permute, Dense)\"\n@test brief(transpose(base)) == \"3 x 4 x Float64 in Columns (Transpose, Permute, Dense)\"\n@test brief(transposer(base)) == \"3 x 4 x Float64 in Rows (Transpose, Dense)\"\n\nbase = PermutedDimsArray(rand(3, 4), (1,2))\n@test transposer(base) == transpose(base)\n@test brief(base) == \"3 x 4 x Float64 in Columns (!Permute, Dense)\"\n@test brief(transpose(base)) == \"4 x 3 x Float64 in Rows (Transpose, !Permute, Dense)\"\n@test brief(transposer(base)) == \"4 x 3 x Float64 in Columns (Dense)\"\n\n# LinearAlgebra\n\nusing LinearAlgebra\n\nbase = transpose(rand(3, 4))\n@test transposer(base) == transpose(base)\n@test brief(base) == \"4 x 3 x Float64 in Rows (Transpose, Dense)\"\n@test brief(transpose(base)) == \"3 x 4 x Float64 in Columns (Dense)\"\n@test brief(transposer(base)) == \"3 x 4 x Float64 in Rows (Transpose, Dense)\"\n\nbase = adjoint(rand(3, 4))\n@test transposer(base) == transpose(base)\n@test brief(base) == \"4 x 3 x Float64 in Rows (Adjoint, Dense)\"\n@test brief(transpose(base)) == \"3 x 4 x Float64 in Columns (Dense)\"\n@test brief(transposer(base)) == \"3 x 4 x Float64 in Rows (Adjoint, Dense)\"\n\n# ReadOnly\n\nbase = read_only_array(rand(3, 4))\n@test transposer(base) == transpose(base)\n@test brief(base) == \"3 x 4 x Float64 in Columns (ReadOnly, Dense)\"\n@test brief(transpose(base)) == \"4 x 3 x Float64 in Rows (Transpose, ReadOnly, Dense)\"\n@test brief(transposer(base)) == \"4 x 3 x Float64 in Columns (Dense)\"\n\n# Sparse\n\nusing SparseArrays\n\nbase = SparseMatrixCSC([0.0 1.0 2.0; 3.0 4.0 0.0])\n@test transposer(base) == transpose(base)\n@test brief(base) == \"2 x 3 x Float64 in Columns (Sparse Int64 67%)\"\n@test brief(transpose(base)) == \"3 x 2 x Float64 in Rows (Transpose, Sparse Int64 67%)\"\n@test brief(transposer(base)) == \"3 x 2 x Float64 in Columns (Sparse Int64 67%)\"\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.@assert_vector","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.@assert_vector","text":"@assert_vector(vector::Any, [n_elements::Integer])\n\nAssert that the vector is an AbstractVector and optionally that it has n_elements, with a friendly error message if it fails.\n\nvector = [0, 1, 2]\n\n@assert_vector(vector)\nn_elements = 3\n@assert_vector(vector, n_elements)\nm_elements = 2\n@assert_vector(vector, m_elements)\n\n# output\n\nERROR: wrong size: 3\nof the vector: vector\nis different from m_elements: 2\n\nscalar = 1\n@assert_vector(scalar)\n\n# output\n\nERROR: non-vector scalar: 1\n\n\n\n\n\n","category":"macro"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.@assert_matrix","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.@assert_matrix","text":"@assert_matrix(matrix::Any, [n_rows::Integer, n_columns::Integer], [major_axis::Int8])\n\nAssert that the matrix is an AbstractMatrix and optionally that it has n_rows and n_columns. If the major_axis is given, and does not match the matrix, invokes the GLOBAL_INEFFICIENT_ACTION_HANDLER.\n\nmatrix = [0 1 2; 3 4 0]\n\n@assert_matrix(matrix)\nn_rows, n_columns = (2, 3)\n@assert_matrix(matrix, Columns)\n@assert_matrix(matrix, n_rows, n_columns)\n@assert_matrix(matrix, n_rows, n_columns, Columns)\n\nm_rows, m_columns = (3, 2)\n@assert_matrix(matrix, m_rows, m_columns)\n\n# output\n\nERROR: wrong size: (2, 3)\nof the matrix: matrix\nis different from (m_rows, m_columns): (3, 2)\n\nmatrix = [0 1 2; 3 4 0]\n\nTanayLabUtilities.MatrixLayouts.GLOBAL_INEFFICIENT_ACTION_HANDLER = IgnoreHandler\n\n@assert_matrix(matrix, Rows)\n\nTanayLabUtilities.MatrixLayouts.GLOBAL_INEFFICIENT_ACTION_HANDLER = ErrorHandler\n\n@assert_matrix(matrix, Rows)\n\n# output\n\nERROR: inefficient major axis: Columns\nfor matrix: 2 x 3 x Int64 in Columns (Dense)\n\n\n\n\n\n","category":"macro"},{"location":"matrix_layouts.html#TanayLabUtilities.MatrixLayouts.GLOBAL_INEFFICIENT_ACTION_HANDLER","page":"Matrix layouts","title":"TanayLabUtilities.MatrixLayouts.GLOBAL_INEFFICIENT_ACTION_HANDLER","text":"The AbnormalHandler to use when accessing a matrix in an inefficient way (\"against the grain\"). Returns the previous handler. The default handler is WarnHandler.\n\n\n\n\n\n","category":"constant"},{"location":"matrix_layouts.html#Index","page":"Matrix layouts","title":"Index","text":"","category":"section"},{"location":"matrix_layouts.html","page":"Matrix layouts","title":"Matrix layouts","text":"Pages = [\"matrix_layouts.md\"]","category":"page"},{"location":"parallel_rng.html#ParallelRNG","page":"ParallelRNG","title":"ParallelRNG","text":"","category":"section"},{"location":"parallel_rng.html","page":"ParallelRNG","title":"ParallelRNG","text":"TanayLabUtilities.ParallelRNG\nTanayLabUtilities.ParallelRNG.parallel_loop_with_rng","category":"page"},{"location":"parallel_rng.html#TanayLabUtilities.ParallelRNG","page":"ParallelRNG","title":"TanayLabUtilities.ParallelRNG","text":"Reproducible random number generator for parallel loops. Yes, the TaskLocalRNG is supposed to do this, but, it actually depends on the way tasks are allocated to threads. The implementation here will give the same results regardless of the thread scheduling policy.\n\n\n\n\n\n","category":"module"},{"location":"parallel_rng.html#TanayLabUtilities.ParallelRNG.parallel_loop_with_rng","page":"ParallelRNG","title":"TanayLabUtilities.ParallelRNG.parallel_loop_with_rng","text":"parallel_loop_with_rng(\n    body::Function,\n    indices::AbstractVector{<:Integer},\n    policy::Symbol = :greedy,\n    seed::Maybe{Integer} = nothing,\n    rng::Maybe{AbstractRNG} = nothing\n)::Nothing\n\nRun the body in parallel, passing it the iteration indices, and a separaterngthat is seeded to a reproducible state regardless of the allocation of tasks to threads. A copy of thisrngis given to each iteration, after being reset toseed + indexfor reproducibility. If noseedis specified, it is just sampledrngbefore the loop starts. If therngisn't given, then this uses (and sets for each iteration) thedefault_rng()`. In this case passing it to the body is redundant but is still done for consistency.\n\nThe policy is passed to @threads if it is one of (the default :greedy, :dynamic, or :static). If it is :serial, then the loop is not run in parallel (useful for debugging).\n\nusing Test\nusing Random\n\nsize = 10\n\nfunction collect_rng(rng::AbstractRNG)::Vector{Float64}\n    results = zeros(Float64, size)\n    parallel_loop_with_rng(1:size; rng) do index, rng\n        results[index] = rand(rng)\n    end\n    @test results[1] != results[2]\n    return results\nend\n\n@test collect_rng(MersenneTwister(1)) == collect_rng(MersenneTwister(1))\n\nfunction collect_default_rng()::Vector{Float64}\n    results = zeros(Float64, size)\n    parallel_loop_with_rng(1:size; seed = 123456, policy = :dynamic) do index, _\n        results[index] = rand()\n    end\n    @test results[1] != results[2]\n    return results\nend\n\n@test collect_default_rng() == collect_default_rng()\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"parallel_rng.html#Index","page":"ParallelRNG","title":"Index","text":"","category":"section"},{"location":"parallel_rng.html","page":"ParallelRNG","title":"ParallelRNG","text":"Pages = [\"parallel_rng.md\"]","category":"page"},{"location":"locks.html#Locks","page":"Locks","title":"Locks","text":"","category":"section"},{"location":"locks.html","page":"Locks","title":"Locks","text":"TanayLabUtilities.Locks\nTanayLabUtilities.Locks.ReentrantReadWriteLock","category":"page"},{"location":"locks.html#TanayLabUtilities.Locks","page":"Locks","title":"TanayLabUtilities.Locks","text":"Generic (reentrant) read-write locks.\n\nThese add functionality on top of ConcurrentUtils; specifically, they allow querying the status of the lock, and querying the status of the lock. We also provide explicit write_* and read_* functions instead of relying on lock to be write_lock. That is, ReentrantReadWriteLock is not an AbstractLock.\n\nread_write_lock = ReentrantReadWriteLock()\n\n@assert !has_write_lock(read_write_lock)\n@assert !has_read_lock(read_write_lock)\n\nwith_write_lock(read_write_lock, \"top_write\") do\n    @assert has_write_lock(read_write_lock)\n    @assert has_read_lock(read_write_lock)\n\n    with_write_lock(read_write_lock, \"nested_write\") do\n        @assert has_write_lock(read_write_lock)\n        @assert has_read_lock(read_write_lock)\n    end\n\n    with_read_lock(read_write_lock, \"nested_read\") do\n        @assert has_write_lock(read_write_lock)\n        @assert has_read_lock(read_write_lock)\n    end\nend\n\n@assert !has_write_lock(read_write_lock)\n@assert !has_read_lock(read_write_lock)\n\n# output\n\n\nread_write_lock = ReentrantReadWriteLock()\n\n@assert !has_write_lock(read_write_lock)\n@assert !has_read_lock(read_write_lock)\n\nwith_read_lock(read_write_lock, \"top_read\") do\n    @assert !has_write_lock(read_write_lock)\n    @assert has_read_lock(read_write_lock)\n\n    with_read_lock(read_write_lock, \"nested_read\") do\n        @assert !has_write_lock(read_write_lock)\n        @assert has_read_lock(read_write_lock)\n    end\nend\n\n@assert !has_write_lock(read_write_lock)\n@assert !has_read_lock(read_write_lock)\n\n# output\n\n\nread_write_lock = ReentrantReadWriteLock()\n\n@assert !has_write_lock(read_write_lock)\n@assert !has_read_lock(read_write_lock)\n\nwith_read_lock(read_write_lock, \"top_read\") do\n    @assert !has_write_lock(read_write_lock)\n    @assert has_read_lock(read_write_lock)\n\n    with_write_lock(read_write_lock, \"nested_write\") do\n        @assert false\n    end\nend\n\n# output\n\nERROR: trying to obtain write lock for: nested_write\nwhile holding read lock:\n\n\n\n\n\n","category":"module"},{"location":"locks.html#TanayLabUtilities.Locks.ReentrantReadWriteLock","page":"Locks","title":"TanayLabUtilities.Locks.ReentrantReadWriteLock","text":"struct ReentrantReadWriteLock <: AbstractLock ... end\n\nA read-write lock that supports nested calls. You can nest read locks, write locks, and read locks inside write locks. However, you can't nest write locks in read locks.\n\n\n\n\n\n","category":"type"},{"location":"locks.html#Write-Lock","page":"Locks","title":"Write Lock","text":"","category":"section"},{"location":"locks.html","page":"Locks","title":"Locks","text":"TanayLabUtilities.Locks.write_lock\nTanayLabUtilities.Locks.write_unlock\nTanayLabUtilities.Locks.with_write_lock\nTanayLabUtilities.Locks.has_write_lock","category":"page"},{"location":"locks.html#TanayLabUtilities.Locks.write_lock","page":"Locks","title":"TanayLabUtilities.Locks.write_lock","text":"write_lock(read_write_lock::ReentrantReadWriteLock, what::Any...)::Nothing\n\nObtain a write lock. Each call must be matched by write_unlock. It is possible to nest write_lock/write_unlock call pairs.\n\nWhen a task has a write lock, no other task can have any lock.\n\nThe log messages includes what is being locked.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#TanayLabUtilities.Locks.write_unlock","page":"Locks","title":"TanayLabUtilities.Locks.write_unlock","text":"write_unlock(read_write_lock::ReentrantReadWriteLock, what::Any)::Nothing\n\nRelease a write lock. Each call must matched a call to write_lock. It is possible to nest write_lock/write_unlock call pairs.\n\nThe log messages includes what is being unlocked.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#TanayLabUtilities.Locks.with_write_lock","page":"Locks","title":"TanayLabUtilities.Locks.with_write_lock","text":"with_write_lock(action::Function, read_write_lock::ReentrantReadWriteLock, what::Any...)::Any\n\nPerform an action while holding a write_lock for the read_write_lock, return its result and write_unlock.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#TanayLabUtilities.Locks.has_write_lock","page":"Locks","title":"TanayLabUtilities.Locks.has_write_lock","text":"has_write_lock(read_write_lock::ReentrantReadWriteLock)::Bool\n\nReturn whether the current task has the write lock.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#Read-Locks","page":"Locks","title":"Read Locks","text":"","category":"section"},{"location":"locks.html","page":"Locks","title":"Locks","text":"TanayLabUtilities.Locks.read_lock\nTanayLabUtilities.Locks.read_unlock\nTanayLabUtilities.Locks.with_read_lock\nTanayLabUtilities.Locks.has_read_lock","category":"page"},{"location":"locks.html#TanayLabUtilities.Locks.read_lock","page":"Locks","title":"TanayLabUtilities.Locks.read_lock","text":"read_lock(read_write_lock::ReentrantReadWriteLock, what::Any...)::Nothing\n\nObtain a read lock. Each call must be matched by read_unlock. It is possible to nest read_lock/read_unlock call pairs, even inside write_lock/write_unlock pair(s); however, you can't nest write_lock/write_unlock inside a read_lock/read_unlock pair.\n\nWhen a task has a read lock, no other task can have a write lock, but other tasks may also have a read lock.\n\nThe log messages includes what is being locked.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#TanayLabUtilities.Locks.read_unlock","page":"Locks","title":"TanayLabUtilities.Locks.read_unlock","text":"read_unlock(read_write_lock::ReentrantReadWriteLock, what::Any...)::Nothing\n\nRelease a read lock. Each call must matched a call to read_lock. It is possible to nest read_lock/read_unlock call pairs.\n\nThe log messages includes what is being unlocked.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#TanayLabUtilities.Locks.with_read_lock","page":"Locks","title":"TanayLabUtilities.Locks.with_read_lock","text":"with_read_lock(action::Function, read_write_lock::ReentrantReadWriteLock, what::Any...)::Any\n\nPerform an action while holding a read_lock for the read_write_lock, return its result and read_unlock.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#TanayLabUtilities.Locks.has_read_lock","page":"Locks","title":"TanayLabUtilities.Locks.has_read_lock","text":"has_read_lock(read_write_lock::ReentrantReadWriteLock; read_only::Bool = false)::Bool\n\nReturn whether the current task has a read lock or the write lock. If read_only is set, then this will only return whether the current task as a read lock.\n\n\n\n\n\n","category":"function"},{"location":"locks.html#Index","page":"Locks","title":"Index","text":"","category":"section"},{"location":"locks.html","page":"Locks","title":"Locks","text":"Pages = [\"locks.md\"]","category":"page"},{"location":"matrix_formats.html#Matrix-Formats","page":"Matrix Formats","title":"Matrix Formats","text":"","category":"section"},{"location":"matrix_formats.html","page":"Matrix Formats","title":"Matrix Formats","text":"TanayLabUtilities.MatrixFormats\nTanayLabUtilities.MatrixFormats.copy_array\nTanayLabUtilities.MatrixFormats.similar_array\nTanayLabUtilities.MatrixFormats.sparse_matrix_csc\nTanayLabUtilities.MatrixFormats.sparse_vector\nTanayLabUtilities.MatrixFormats.sparse_mask_vector\nTanayLabUtilities.MatrixFormats.dense_mask_vector\nTanayLabUtilities.MatrixFormats.sparsify\nTanayLabUtilities.MatrixFormats.densify\nTanayLabUtilities.MatrixFormats.bestify\nTanayLabUtilities.MatrixFormats.indtype_for_size\nTanayLabUtilities.MatrixFormats.colptr\nTanayLabUtilities.MatrixFormats.rowval\nTanayLabUtilities.MatrixFormats.nzind\nTanayLabUtilities.MatrixFormats.nzval","category":"page"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats","text":"Deal with (some) of the matrix formats. This obviously can't be compherensive but it should cover the matrix types we have encountered so far and hopefully falls back to reasonable defaults for more exotic matrix types.\n\nIn Julia, many array types are wrappers around \"parent\" arrays. The specific wrappers we deal with in most cases are NamedArray which adds names to the rows and/or columns, PermutedDimsArray which flips the order of the axes, Transpose and Adjoint which likewise flip the axes (Adjoint also transforms complex values), and ReadOnlyArray which prevents mutating the array. And then there are more transformative wrappers such as SubArray, SparseVector and SparseMatrixCSC, PyArray, etc.\n\nThis makes life difficult. Specifically, you can't rely (much) on the type system to separate code dealing with different array types. For example, not all issparse arrays derive from AbstractSparseArray (because you might have a sparse array wrapped in something). It would have been great if there were isdense and isstrided functions to match and libraries actually used them to trigger optimized code but \"that would have been too easy\".\n\nThe code here tries to put this under some control so we can write robust code which \"does the right thing\", in most cases, at least when it comes to converting between formats. This means we are forced to provide alternatives to some built-in functions (for example, copying arrays). Sigh.\n\n\n\n\n\n","category":"module"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.copy_array","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.copy_array","text":"copy_array(array::AbstractArray; eltype::Maybe{Type} = nothing, indtype::Maybe{Type} = nothing)::AbstractArray\n\nCreate a copy of an array. This differs from Base.copy in the following:\n\nCopying a read-only array returns a mutable array. In contrast, both Base.copy and Base.deepcopy of a ReadOnlyArray array will return a ReadOnlyArray array, which is technically correct, but is rather pointless.\nCopying a NamedArray returns a NamedArray that shares the names (but not the data storage).\nCopying will preserve the layout of the data; for example, copying a Transpose array is still a Transpose array. In contrast, while Base.deepcopy will preserve the layout, Base.copy will silently relayout the matrix, which is both expensive and unexpected.\nCopying a sparse vector or matrix gives a sparse result. Copying anything else gives a simple dense array regardless of the original type. This is done because a deepcopy of PyArray will still share the underlying buffer, which removes the whole point of doing a copy. Sigh.\nCopying a vector of anything derived from AbstractString returns a vector of AbstractString.\nYou can override the eltype of the array (and/or the indtype, if it is sparse).\n\nusing Test\n\nbase = [0 1 2; 3 4 0]\n\n# Dense\n\n@test brief(base) == \"2 x 3 x Int64 in Columns (Dense)\"\n@test brief(copy_array(base)) == \"2 x 3 x Int64 in Columns (Dense)\"\n@test copy_array(base) == base\n@test copy_array(base) !== base\n\n@test copy_array(base; eltype = Int32) == base\n@test brief(copy_array(base; eltype = Int32)) == \"2 x 3 x Int32 in Columns (Dense)\"\n\n# Sparse\n\nusing SparseArrays\n\nsparse = SparseMatrixCSC(base)\n@test copy_array(sparse) == sparse\n@test copy_array(sparse) !== sparse\n@test brief(sparse) == \"2 x 3 x Int64 in Columns (Sparse Int64 67%)\"\n@test brief(copy_array(sparse)) == \"2 x 3 x Int64 in Columns (Sparse Int64 67%)\"\n\n@test copy_array(sparse; eltype = Int32) == sparse\n@test brief(copy_array(sparse; eltype = Int32)) == \"2 x 3 x Int32 in Columns (Sparse Int64 67%)\"\n\n@test copy_array(sparse; indtype = Int8) == sparse\n@test brief(copy_array(sparse; indtype = Int8)) == \"2 x 3 x Int64 in Columns (Sparse Int8 67%)\"\n\n# ReadOnly\n\nread_only = read_only_array(base)\n@test brief(read_only) == \"2 x 3 x Int64 in Columns (ReadOnly, Dense)\"\n@test brief(copy_array(read_only)) == \"2 x 3 x Int64 in Columns (Dense)\"\n@test copy_array(read_only) == read_only\n@test copy_array(read_only) !== base\n\n# Named\n\nusing NamedArrays\n\nnamed = NamedArray(base)\n@test brief(named) == \"2 x 3 x Int64 in Columns (Named, Dense)\"\n@test brief(copy_array(named)) == \"2 x 3 x Int64 in Columns (Named, Dense)\"\n@test copy_array(named) == named\n@test parent(copy_array(named)) !== base\n\n# Permuted\n\npermuted = PermutedDimsArray(base, (2, 1))\n@test brief(permuted) == \"3 x 2 x Int64 in Rows (Permute, Dense)\"\n@test brief(copy_array(permuted)) == \"3 x 2 x Int64 in Rows (Permute, Dense)\"\n@test copy_array(permuted) == permuted\n@test parent(copy_array(permuted)) !== base\n\nunpermuted = PermutedDimsArray(base, (1, 2))\n@test brief(unpermuted) == \"2 x 3 x Int64 in Columns (!Permute, Dense)\"\n@test brief(copy_array(unpermuted)) == \"2 x 3 x Int64 in Columns (!Permute, Dense)\"\n@test copy_array(unpermuted) == unpermuted\n@test parent(copy_array(unpermuted)) !== base\n\n# LinearAlgebra\n\nusing LinearAlgebra\n\ntransposed = transpose(base)\n@test brief(transposed) == \"3 x 2 x Int64 in Rows (Transpose, Dense)\"\n@test brief(copy_array(transposed)) == \"3 x 2 x Int64 in Rows (Transpose, Dense)\"\n@test copy_array(transposed) == transposed\n@test parent(copy_array(transposed)) !== base\n\nadjointed = adjoint(base)\n@test brief(adjointed) == \"3 x 2 x Int64 in Rows (Adjoint, Dense)\"\n@test brief(copy_array(adjointed)) == \"3 x 2 x Int64 in Rows (Adjoint, Dense)\"\n@test copy_array(adjointed) == adjointed\n@test parent(copy_array(adjointed)) !== base\n\nprintln(\"OK\")\n\n# output\n\nOK\n\nusing Test\n\n# Dense\n\nbase = [0, 1, 2]\n\n@test brief(base) == \"3 x Int64 (Dense)\"\n@test brief(copy_array(base)) == \"3 x Int64 (Dense)\"\n@test copy_array(base) == base\n@test copy_array(base) !== base\n\n# Sparse\n\nusing SparseArrays\n\nsparse = SparseVector(base)\n@test brief(sparse) == \"3 x Int64 (Sparse Int64 67%)\"\n@test brief(copy_array(sparse)) == \"3 x Int64 (Sparse Int64 67%)\"\n@test copy_array(sparse) == sparse\n@test copy_array(sparse) !== sparse\n\n# ReadOnly\n\nread_only = read_only_array(base)\n@test brief(read_only) == \"3 x Int64 (ReadOnly, Dense)\"\n@test brief(copy_array(read_only)) == \"3 x Int64 (Dense)\"\n@test copy_array(read_only) == read_only\n@test copy_array(read_only) !== base\n\n# Named\n\nusing NamedArrays\n\nnamed = NamedArray(base)\n@test brief(named) == \"3 x Int64 (Named, Dense)\"\n@test brief(copy_array(named)) == \"3 x Int64 (Named, Dense)\"\n@test copy_array(named) == named\n@test parent(copy_array(named)) !== base\n\n# LinearAlgebra\n\nusing LinearAlgebra\n\ntransposed = transpose(base)\n@test brief(transposed) == \"3 x Int64 (Transpose, Dense)\"\n@test brief(copy_array(transposed)) == \"3 x Int64 (Transpose, Dense)\"\n@test copy_array(transposed) == transposed\n@test parent(copy_array(transposed)) !== base\n\nadjointed = adjoint(base)\n@test brief(adjointed) == \"3 x Int64 (Adjoint, Dense)\"\n@test brief(copy_array(adjointed)) == \"3 x Int64 (Adjoint, Dense)\"\n@test copy_array(adjointed) == adjointed\n@test parent(copy_array(adjointed)) !== base\n\n# String\n\nbase = split(\"abc\", \"\")\n\n@test brief(base) == \"3 x Str (Dense)\"\n@test brief(copy_array(base)) == \"3 x Str (Dense)\"\n@test eltype(base) != AbstractString\n@test eltype(copy_array(base)) == AbstractString\n@test copy_array(base) == base\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.similar_array","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.similar_array","text":"similar_array(\n    array::AbstractArray;\n    [value::Any = undef,\n    eltype::Maybe{Type} = nothing,\n    default_major_axis::Maybe{Integer} = Columns]\n)::AbstractArray\nend\n\nReturn an array (vector or a matrix) similar to the given one. By default the data has the same eltype as the original, and is uninitialized unless you specify a value. The returned data is always dense (Vector or Matrix).\n\nThis is different from similar in that it will preserve the layout of a matrix (for example, similar_array of a transpose will also be a transpose). Also, similar_array of a NamedArray will be another NamedArray sharing the axes with the original, and ReadOnlyArray wrappers are stripped from the result. If the array is a matrix with no clear major_axis, such as a @views slice of a matrix, then the result will have the default_major_axis.\n\nusing Test\n\nbase = rand(3, 4)\n\n@test brief(base) == \"3 x 4 x Float64 in Columns (Dense)\"\n@test similar_array(base) !== base\n@test brief(similar_array(base)) == \"3 x 4 x Float64 in Columns (Dense)\"\n\n@test brief(similar_array(base; eltype = Int32)) == \"3 x 4 x Int32 in Columns (Dense)\"\n@test brief(similar_array(base; value = 0.0)) == \"3 x 4 x Float64 in Columns (Dense)\"\n@test all(similar_array(base; value = 0.0) .== 0)\n\n# ReadOnly\n\nread_only = read_only_array(base)\n@test brief(read_only) == \"3 x 4 x Float64 in Columns (ReadOnly, Dense)\"\n@test brief(similar_array(read_only)) == \"3 x 4 x Float64 in Columns (Dense)\"\n\n# Named\n\nusing NamedArrays\n\nnamed = NamedArray(base)\n@test brief(named) == \"3 x 4 x Float64 in Columns (Named, Dense)\"\n@test similar_array(named) !== named\n@test brief(similar_array(named)) == \"3 x 4 x Float64 in Columns (Named, Dense)\"\n\n# Permuted\n\npermuted = PermutedDimsArray(base, (2, 1))\n@test brief(permuted) == \"4 x 3 x Float64 in Rows (Permute, Dense)\"\n@test similar_array(permuted) !== permuted\n@test brief(similar_array(permuted)) == \"4 x 3 x Float64 in Rows (Permute, Dense)\"\n\n# LinearAlgebra\n\ntransposed = transpose(base)\n@test brief(transposed) == \"4 x 3 x Float64 in Rows (Transpose, Dense)\"\n@test similar_array(transposed) !== transposed\n@test brief(similar_array(transposed)) == \"4 x 3 x Float64 in Rows (Transpose, Dense)\"\n\nadjointed = adjoint(base)\n@test brief(adjointed) == \"4 x 3 x Float64 in Rows (Adjoint, Dense)\"\n@test similar_array(adjointed) !== adjointed\n@test brief(similar_array(adjointed)) == \"4 x 3 x Float64 in Rows (Adjoint, Dense)\"\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.sparse_matrix_csc","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.sparse_matrix_csc","text":"sparse_matrix_csc(\n    matrix::AbstractMatrix;\n    eltype::Maybe{Type} = nothing,\n    indtype::Maybe{Type} = nothing\n)::SparseMatrixCSC\n\nsparse_matrix_csc(\n    colptr::AbstractVector,\n    rowval::AbstractVector,\n    nzval::AbstractVector\n)::Union{ReadOnlyArray, SparseMatrixCSC}\n\nCreate a sparse column-major matrix. This differs from the simple SparseMatrixCSC in the following ways:\n\nThe integer index type is UInt32 if possible. Only very large matrix sizes use UInt64. This greatly reduces the size of large matrices.\nIf constructing the matrix from three vectors, then if any of them are ReadOnlyArray, this will return a ReadOnlyArray wrapper for the result (which will internally refer to the mutable arrays).\nIf eltype is specified, this will be the element type of the result.\n\nusing Test\n\n# Matrix\n\n@test brief(sparse_matrix_csc([0 1 2; 3 4 0])) == \"2 x 3 x Int64 in Columns (Sparse UInt32 67%)\"\n@test brief(sparse_matrix_csc([0 1 2; 3 4 0]; eltype = Float32)) == \"2 x 3 x Float32 in Columns (Sparse UInt32 67%)\"\n@test brief(sparse_matrix_csc([0 1 2; 3 4 0]; indtype = UInt8)) == \"2 x 3 x Int64 in Columns (Sparse UInt8 67%)\"\n\n# Vectors\n\nsparse = sparse_matrix_csc([0 1 2; 3 4 0])\n\n@test brief(sparse_matrix_csc(2, 3, sparse.colptr, sparse.rowval, sparse.nzval)) == \"2 x 3 x Int64 in Columns (Sparse UInt32 67%)\"\n@test brief(sparse_matrix_csc(2, 3, read_only_array(sparse.colptr), read_only_array(sparse.rowval), read_only_array(sparse.nzval))) ==\n      \"2 x 3 x Int64 in Columns (ReadOnly, Sparse UInt32 67%)\"\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.sparse_vector","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.sparse_vector","text":"sparse_vector(\n    vector::AbstractMatrix;\n    eltype::Maybe{Type} = nothing,\n    indtype::Maybe{Type} = nothing,\n)::SparseVector\n\nsparse_vector(\n    size::Integer,\n    inzind::AbstractVector,\n    nzval::AbstractVector\n)::Union{ReadOnlyArray, SparseVector}\n\nCreate a sparse vector. This differs from the simple SparseVector in the following ways:\n\nThe integer index type is UInt32 if possible. Only very large matrix sizes use UInt64. This greatly reduces the size of large matrices.\nIf constructing the vector from two vectors, then if any of them are ReadOnlyArray, this will return a ReadOnlyArray wrapper for the result (which will internally refer to the mutable arrays).\nIf eltype is specified, this will be the element type of the result.\n\nusing Test\n\n# Vector\n\n@test brief(sparse_vector([0, 1, 2])) == \"3 x Int64 (Sparse UInt32 67%)\"\n@test brief(sparse_vector([0, 1, 2]; eltype = Float32)) == \"3 x Float32 (Sparse UInt32 67%)\"\n\n# Vectors\n\n@test brief(sparse_vector(3, [1, 3], [1.0, 2.0])) == \"3 x Float64 (Sparse Int64 67%)\"\n@test brief(sparse_vector(3, read_only_array([1, 3]), read_only_array([1.0, 2.0]))) == \"3 x Float64 (ReadOnly, Sparse Int64 67%)\"\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.sparse_mask_vector","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.sparse_mask_vector","text":"sparse_mask_vector(\n    size::Integer,\n    inzind::AbstractVector\n)::Union{ReadOnlyArray, SparseVector{Bool}}\n\nCreate a sparse mask vector using only the indices of the true entries. Alas, this still needs to allocate a vector of Bool for the data.\n\nusing Test\n\n@test brief(sparse_mask_vector(3, [1, 3])) == \"3 x Bool (Sparse Int64 67%)\"\n@test brief(sparse_mask_vector(3, read_only_array([1, 3]))) == \"3 x Bool (ReadOnly, Sparse Int64 67%)\"\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.dense_mask_vector","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.dense_mask_vector","text":"dense_mask_vector(\n    size::Integer,\n    inzind::AbstractVector\n)::Vector{Bool}\n\nCreate a dense mask vector using only the indices of the true entries.\n\nprintln(brief(dense_mask_vector(4, [1, 3])))\n\n# output\n\n4 x Bool (Dense; 50% true)\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.sparsify","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.sparsify","text":"sparsify(\n    matrix::AbstractMatrix;\n    copy::Bool = false,\n    eltype::Maybe{Type} = nothing,\n    indtype::Maybe{Type} = nothing\n)::AbstractMatrix\n\nsparsify(\n    vector::AbstractVector;\n    copy::Bool = false,\n    eltype::Maybe{Type} = nothing,\n    indtype::Maybe{Type} = nothing\n)::AbstractVector\n\nReturn a sparse version of an array, possibly forcing a different eltype and/or indtype. If given a dense matrix, the default indtype will be indtype_for_size for the matrix. This will preserve the matrix layout (for example, sparsify of a transposed matrix will be a transposed matrix). If copy, this will create a copy even if it is already sparse and has the correct eltype and indtype.\n\nusing Test\nusing SparseArrays\n\n# Dense\n\ndense = rand(3, 4)\n@test sparsify(dense) == dense\n@test brief(dense) == \"3 x 4 x Float64 in Columns (Dense)\"\n@test brief(sparsify(dense)) == \"3 x 4 x Float64 in Columns (Sparse UInt32 100%)\"\n\n# Sparse\n\nsparse = SparseMatrixCSC([0 1 2; 3 4 0])\n@test sparsify(sparse) === sparse\n@test brief(sparse) == \"2 x 3 x Int64 in Columns (Sparse Int64 67%)\"\n\n@test sparsify(sparse; copy = true) == sparse\n@test sparsify(sparse; copy = true) !== sparse\n@test brief(sparsify(sparse)) == \"2 x 3 x Int64 in Columns (Sparse Int64 67%)\"\n\n@test sparsify(sparse; eltype = Int8) == sparse\n@test brief(sparsify(sparse; eltype = Int8)) == \"2 x 3 x Int8 in Columns (Sparse Int64 67%)\"\n\n@test sparsify(sparse; indtype = Int8) == sparse\n@test brief(sparsify(sparse; indtype = Int8)) == \"2 x 3 x Int64 in Columns (Sparse Int8 67%)\"\n\n# ReadOnly\n\nread_only = read_only_array(sparse)\n@test sparsify(read_only) === read_only\n@test brief(read_only) == \"2 x 3 x Int64 in Columns (ReadOnly, Sparse Int64 67%)\"\n\nread_only = read_only_array(dense)\n@test sparsify(read_only) == read_only\n@test brief(sparsify(read_only)) == \"3 x 4 x Float64 in Columns (ReadOnly, Sparse UInt32 100%)\"\n\n# Named\n\nusing NamedArrays\n\nnamed = NamedArray(sparse)\n@test sparsify(named) === named\n@test brief(named) == \"2 x 3 x Int64 in Columns (Named, Sparse Int64 67%)\"\n\nnamed = NamedArray(dense)\n@test sparsify(named) == named\n@test brief(sparsify(named)) == \"3 x 4 x Float64 in Columns (Named, Sparse UInt32 100%)\"\n\n# Permuted\n\npermuted = PermutedDimsArray(sparse, (2, 1))\n@test sparsify(permuted) === permuted\n@test brief(permuted) == \"3 x 2 x Int64 in Rows (Permute, Sparse Int64 67%)\"\n\nunpermuted = PermutedDimsArray(sparse, (1, 2))\n@test sparsify(unpermuted) === unpermuted\n@test brief(unpermuted) == \"2 x 3 x Int64 in Columns (!Permute, Sparse Int64 67%)\"\n\npermuted = PermutedDimsArray(dense, (2, 1))\n@test sparsify(permuted) == permuted\n@test brief(permuted) == \"4 x 3 x Float64 in Rows (Permute, Dense)\"\n@test brief(sparsify(permuted)) == \"4 x 3 x Float64 in Rows (Permute, Sparse UInt32 100%)\"\n\nunpermuted = PermutedDimsArray(dense, (1, 2))\n@test sparsify(unpermuted) == unpermuted\n@test brief(unpermuted) == \"3 x 4 x Float64 in Columns (!Permute, Dense)\"\n@test brief(sparsify(unpermuted)) == \"3 x 4 x Float64 in Columns (!Permute, Sparse UInt32 100%)\"\n\n# LinearAlgebra\n\ntransposed = transpose(sparse)\n@test sparsify(transposed) === transposed\n@test brief(transposed) == \"3 x 2 x Int64 in Rows (Transpose, Sparse Int64 67%)\"\n\nadjointed = adjoint(sparse)\n@test sparsify(adjointed) === adjointed\n@test brief(adjointed) == \"3 x 2 x Int64 in Rows (Adjoint, Sparse Int64 67%)\"\n\ntransposed = transpose(dense)\n@test sparsify(transposed) == transposed\n@test brief(transposed) == \"4 x 3 x Float64 in Rows (Transpose, Dense)\"\n@test brief(sparsify(transposed)) == \"4 x 3 x Float64 in Rows (Transpose, Sparse UInt32 100%)\"\n\nadjointed = adjoint(dense)\n@test sparsify(adjointed) == adjointed\n@test brief(adjointed) == \"4 x 3 x Float64 in Rows (Adjoint, Dense)\"\n@test brief(sparsify(adjointed)) == \"4 x 3 x Float64 in Rows (Adjoint, Sparse UInt32 100%)\"\n\nprintln(\"OK\")\n\n# output\n\nOK\n\nusing Test\nusing SparseArrays\n\n# Dense\n\ndense = rand(4)\n@test sparsify(dense) == dense\n@test brief(dense) == \"4 x Float64 (Dense)\"\n@test brief(sparsify(dense)) == \"4 x Float64 (Sparse UInt32 100%)\"\n\n# Sparse\n\nsparse = SparseVector([0, 1, 2, 0])\n@test sparsify(sparse) === sparse\n@test brief(sparse) == \"4 x Int64 (Sparse Int64 50%)\"\n\n@test sparsify(sparse; copy = true) == sparse\n@test sparsify(sparse; copy = true) !== sparse\n@test brief(sparsify(sparse)) == \"4 x Int64 (Sparse Int64 50%)\"\n\n@test sparsify(sparse; eltype = Int8) == sparse\n@test brief(sparsify(sparse; eltype = Int8)) == \"4 x Int8 (Sparse Int64 50%)\"\n\n@test sparsify(sparse; indtype = Int8) == sparse\n@test brief(sparsify(sparse; indtype = Int8)) == \"4 x Int64 (Sparse Int8 50%)\"\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.densify","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.densify","text":"densify(matrix::AbstractMatrix; copy::Bool = false, eltype::Maybe{Type} = nothing)::AbstractMatrix\ndensify(vector::AbstractVector; copy::Bool = false, eltype::Maybe{Type} = nothing)::AbstractVector\n\nReturn a dense version of an array, possibly forcing a different eltype. This will preserve the matrix layout (for example, densify of a transposed matrix will be a transposed matrix). If copy, this will create a copy even if it is already dense and has the correct eltype.\n\nusing Test\nusing SparseArrays\n\n# Dense\n\ndense = rand(3, 4)\n@test densify(dense) === dense\n@test brief(dense) == \"3 x 4 x Float64 in Columns (Dense)\"\n\n@test densify(dense; copy = true) !== dense\n@test densify(dense; copy = true) == dense\n@test brief(densify(dense; copy = true)) == \"3 x 4 x Float64 in Columns (Dense)\"\n\n@test isapprox(densify(dense; eltype = Float32), dense)\n@test brief(densify(dense; eltype = Float32)) == \"3 x 4 x Float32 in Columns (Dense)\"\n\n# Sparse\n\nsparse = SparseMatrixCSC([0 1 2; 3 4 0])\n\n@test densify(sparse) == sparse\n@test brief(densify(sparse)) == \"2 x 3 x Int64 in Columns (Dense)\"\n@test brief(densify(sparse; eltype = Int8)) == \"2 x 3 x Int8 in Columns (Dense)\"\n\n# ReadOnly\n\nread_only = read_only_array(sparse)\n@test densify(read_only) == read_only\n@test brief(read_only) == \"2 x 3 x Int64 in Columns (ReadOnly, Sparse Int64 67%)\"\n@test brief(densify(read_only)) == \"2 x 3 x Int64 in Columns (ReadOnly, Dense)\"\n\nread_only = read_only_array(dense)\n@test densify(read_only) == dense\n\n# Named\n\nusing NamedArrays\n\nnamed = NamedArray(sparse)\n@test densify(named) == named\n@test brief(named) == \"2 x 3 x Int64 in Columns (Named, Sparse Int64 67%)\"\n@test brief(densify(named)) == \"2 x 3 x Int64 in Columns (Named, Dense)\"\n\nnamed = NamedArray(dense)\n@test densify(named) == dense\n\n# Permuted\n\npermuted = PermutedDimsArray(dense, (2, 1))\n@test densify(permuted) === permuted\n@test brief(permuted) == \"4 x 3 x Float64 in Rows (Permute, Dense)\"\n\nunpermuted = PermutedDimsArray(dense, (1, 2))\n@test densify(unpermuted) === unpermuted\n@test brief(unpermuted) == \"3 x 4 x Float64 in Columns (!Permute, Dense)\"\n\npermuted = PermutedDimsArray(sparse, (2, 1))\n@test densify(permuted) == permuted\n@test brief(permuted) == \"3 x 2 x Int64 in Rows (Permute, Sparse Int64 67%)\"\n@test brief(densify(permuted)) == \"3 x 2 x Int64 in Rows (Permute, Dense)\"\n\nunpermuted = PermutedDimsArray(sparse, (1, 2))\n@test densify(unpermuted) == unpermuted\n@test brief(unpermuted) == \"2 x 3 x Int64 in Columns (!Permute, Sparse Int64 67%)\"\n@test brief(densify(unpermuted)) == \"2 x 3 x Int64 in Columns (!Permute, Dense)\"\n\n# LinearAlgebra\n\ntransposed = transpose(dense)\n@test densify(transposed) === transposed\n@test brief(transposed) == \"4 x 3 x Float64 in Rows (Transpose, Dense)\"\n\nadjointed = adjoint(dense)\n@test densify(adjointed) === adjointed\n@test brief(adjointed) == \"4 x 3 x Float64 in Rows (Adjoint, Dense)\"\n\ntransposed = transpose(sparse)\n@test densify(transposed) == transposed\n@test brief(transposed) == \"3 x 2 x Int64 in Rows (Transpose, Sparse Int64 67%)\"\n@test brief(densify(transposed)) == \"3 x 2 x Int64 in Rows (Transpose, Dense)\"\n\nadjointed = adjoint(sparse)\n@test densify(adjointed) == adjointed\n@test brief(adjointed) == \"3 x 2 x Int64 in Rows (Adjoint, Sparse Int64 67%)\"\n@test brief(densify(adjointed)) == \"3 x 2 x Int64 in Rows (Adjoint, Dense)\"\n\nprintln(\"OK\")\n\n# output\n\nOK\n\nusing Test\nusing SparseArrays\n\n# Sparse\n\nsparse = SparseVector([0, 1, 2, 0])\n\n@test densify(sparse) == sparse\n@test brief(densify(sparse)) == \"4 x Int64 (Dense)\"\n\n# Dense\n\ndense = rand(4)\n@test densify(dense) === dense\n@test brief(dense) == \"4 x Float64 (Dense)\"\n\n@test densify(dense; copy = true) !== dense\n@test densify(dense; copy = true) == dense\n@test brief(densify(dense; copy = true)) == \"4 x Float64 (Dense)\"\n\n@test isapprox(densify(dense; eltype = Float32), dense)\n@test brief(densify(dense; eltype = Float32)) == \"4 x Float32 (Dense)\"\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.bestify","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.bestify","text":"bestify(\n    matrix::AbstractMatrix;\n    min_sparse_saving_fraction::AbstractFloat = ```0.25```,\n    copy::Bool = false,\n    eltype::Maybe{Type} = nothing,\n)::AbstractMatrix\n\nbestify(\n    matrix::AbstractVector;\n    min_sparse_saving_fraction::AbstractFloat = ```0.25```,\n    copy::Bool = false,\n    eltype::Maybe{Type} = nothing,\n)::AbstractVector\n\nReturn a \"best\" (dense or sparse) version of an array. The sparse format is chosen if it saves at least min_sparse_saving_fraction of the storage of the dense format. If copy, this will create a copy even if it is already in the best format.\n\nIf eltype is specified, computes the savings (and create the \"best\" version) using this element type. In addition, if given a sparse matrix, we consider the indtype_for_size for it, and if that saves min_sparse_saving_fraction relative to the current sparse representation, we'll create a new one using the better (smaller) indtype.\n\nusing Test\nusing LinearAlgebra\n\n# Dense\n\ndense = zeros(Int32, 5, 5)\nview(dense, diagind(dense)) .= 1\n\n@test bestify(dense) == dense\n@test brief(bestify(dense)) == \"5 x 5 x Int32 in Columns (Sparse UInt32 20%)\"\n\n@test bestify(dense; min_sparse_saving_fraction = 0.5) === dense\n\n# Sparse\n\nsparse = sparse_matrix_csc(dense)\n@test bestify(sparse) === sparse\n@test brief(sparse) == \"5 x 5 x Int32 in Columns (Sparse UInt32 20%)\"\n\n# ReadOnly\n\nread_only = read_only_array(dense)\n@test bestify(read_only; min_sparse_saving_fraction = 0.5) === read_only\n@test brief(read_only) == \"5 x 5 x Int32 in Columns (ReadOnly, Dense)\"\n\n@test bestify(read_only) == read_only\n@test brief(bestify(read_only)) == \"5 x 5 x Int32 in Columns (ReadOnly, Sparse UInt32 20%)\"\n\nread_only = read_only_array(sparse)\n@test bestify(read_only) === read_only\n@test brief(read_only) == \"5 x 5 x Int32 in Columns (ReadOnly, Sparse UInt32 20%)\"\n\n@test bestify(read_only; min_sparse_saving_fraction = 0.5) == read_only\n@test brief(bestify(read_only; min_sparse_saving_fraction = 0.5)) == \"5 x 5 x Int32 in Columns (ReadOnly, Dense)\"\n\n# Named\n\nusing NamedArrays\n\nnamed = NamedArray(dense)\n@test bestify(named; min_sparse_saving_fraction = 0.5) === named\n@test brief(named) == \"5 x 5 x Int32 in Columns (Named, Dense)\"\n\n@test bestify(named) == named\n@test brief(bestify(named)) == \"5 x 5 x Int32 in Columns (Named, Sparse UInt32 20%)\"\n\nnamed = NamedArray(sparse)\n@test bestify(named) === named\n@test brief(named) == \"5 x 5 x Int32 in Columns (Named, Sparse UInt32 20%)\"\n\n@test bestify(named; min_sparse_saving_fraction = 0.5) == named\n@test brief(bestify(named; min_sparse_saving_fraction = 0.5)) == \"5 x 5 x Int32 in Columns (Named, Dense)\"\n\n# Permuted\n\npermuted = PermutedDimsArray(dense, (2, 1))\n@test bestify(permuted; min_sparse_saving_fraction = 0.5) === permuted\n@test brief(permuted) == \"5 x 5 x Int32 in Rows (Permute, Dense)\"\n\n@test bestify(permuted) == permuted\n@test brief(bestify(permuted)) == \"5 x 5 x Int32 in Rows (Permute, Sparse UInt32 20%)\"\n\npermuted = PermutedDimsArray(sparse, (1, 2))\n@test bestify(permuted) === permuted\n@test brief(permuted) == \"5 x 5 x Int32 in Columns (!Permute, Sparse UInt32 20%)\"\n\n@test bestify(permuted; min_sparse_saving_fraction = 0.5) == permuted\n@test brief(bestify(permuted; min_sparse_saving_fraction = 0.5)) == \"5 x 5 x Int32 in Columns (!Permute, Dense)\"\n\n# LinearAlgebra\n\ntransposed = transpose(dense)\n@test bestify(transposed; min_sparse_saving_fraction = 0.5) === transposed\n@test brief(transposed) == \"5 x 5 x Int32 in Rows (Transpose, Dense)\"\n\n@test bestify(transposed) == transposed\n@test brief(bestify(transposed)) == \"5 x 5 x Int32 in Rows (Transpose, Sparse UInt32 20%)\"\n\nadjointed = adjoint(sparse)\n@test bestify(adjointed) === adjointed\n@test brief(adjointed) == \"5 x 5 x Int32 in Rows (Adjoint, Sparse UInt32 20%)\"\n\n@test bestify(adjointed; min_sparse_saving_fraction = 0.5) == adjointed\n@test brief(bestify(adjointed; min_sparse_saving_fraction = 0.5)) == \"5 x 5 x Int32 in Rows (Adjoint, Dense)\"\n\nprintln(\"OK\")\n\n# output\n\nOK\n\nusing Test\nusing LinearAlgebra\n\n# Dense\n\ndense = zeros(Int32, 3)\ndense[1] = 1\n\n@test bestify(dense) == dense\n@test brief(bestify(dense)) == \"3 x Int32 (Sparse UInt32 33%)\"\n\n@test bestify(dense; min_sparse_saving_fraction = 0.5) === dense\n\n# Sparse\n\nsparse = sparse_vector(dense)\n@test bestify(sparse) === sparse\n@test brief(sparse) == \"3 x Int32 (Sparse UInt32 33%)\"\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.indtype_for_size","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.indtype_for_size","text":"indtype_for_size(size::Integer)::Type\n\nReturn the an integer data type which is large enough to hold indices and offsets for a SparseMatrixCSC matrix of some size (total number of elements). We try to use UInt32 whenever possible because for large matrices (especially with 32-bit value types) this will drastically reduce the amount of space used.\n\nprintln(10000000 => indtype_for_size(10000000))\nprintln(10000000000 => indtype_for_size(10000000000))\n\n# output\n\n10000000 => UInt32\n10000000000 => UInt64\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.colptr","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.colptr","text":"colptr(sparse::AbstractMatrix)::AbstractVector{<:Integer}\n\nReturn the colptr of a sparse matrix.\n\nusing Test\nusing NamedArrays\nusing SparseArrays\n\nsparse_matrix = SparseMatrixCSC([0 1 2; 3 4 0])\n@assert colptr(sparse_matrix) === sparse_matrix.colptr\n@assert colptr(read_only_array(sparse_matrix)) === sparse_matrix.colptr\n@assert colptr(NamedArray(sparse_matrix)) === sparse_matrix.colptr\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.rowval","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.rowval","text":"rowval(sparse::AbstractArray)::AbstractVector{<Integer}\n\nReturn the rowval of a sparse array.\n\nusing Test\nusing NamedArrays\nusing SparseArrays\n\nsparse_matrix = SparseMatrixCSC([0 1 2; 3 4 0])\n@assert rowval(sparse_matrix) === sparse_matrix.rowval\n@assert rowval(read_only_array(sparse_matrix)) === sparse_matrix.rowval\n@assert rowval(NamedArray(sparse_matrix)) === sparse_matrix.rowval\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.nzind","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.nzind","text":"nzind(sparse::AbstractVector)::AbstractVector{<:Integer}\n\nReturn the nzind of a sparse vector.\n\nusing Test\nusing NamedArrays\nusing SparseArrays\n\nsparse_vector = SparseVector([0, 1, 2])\n@assert nzind(sparse_vector) === sparse_vector.nzind\n@assert nzind(read_only_array(sparse_vector)) === sparse_vector.nzind\n@assert nzind(NamedArray(sparse_vector)) === sparse_vector.nzind\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#TanayLabUtilities.MatrixFormats.nzval","page":"Matrix Formats","title":"TanayLabUtilities.MatrixFormats.nzval","text":"nzval(sparse::AbstractArray)::AbstractVector\n\nReturn the nzval of a sparse array.\n\nusing Test\nusing NamedArrays\nusing SparseArrays\n\nsparse_matrix = SparseMatrixCSC([0 1 2; 3 4 0])\n@assert nzval(sparse_matrix) === sparse_matrix.nzval\n@assert nzval(read_only_array(sparse_matrix)) === sparse_matrix.nzval\n@assert nzval(NamedArray(sparse_matrix)) === sparse_matrix.nzval\n\nsparse_vector = SparseVector([0, 1, 2])\n@assert nzval(sparse_vector) === sparse_vector.nzval\n@assert nzval(read_only_array(sparse_vector)) === sparse_vector.nzval\n@assert nzval(NamedArray(sparse_vector)) === sparse_vector.nzval\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"matrix_formats.html#Index","page":"Matrix Formats","title":"Index","text":"","category":"section"},{"location":"matrix_formats.html","page":"Matrix Formats","title":"Matrix Formats","text":"Pages = [\"matrix_formats.md\"]","category":"page"},{"location":"brief.html#Brief","page":"Brief","title":"Brief","text":"","category":"section"},{"location":"brief.html","page":"Brief","title":"Brief","text":"TanayLabUtilities.Brief\nTanayLabUtilities.brief\nTanayLabUtilities.MAX_BRIEF_STRING\nTanayLabUtilities.percent","category":"page"},{"location":"brief.html#TanayLabUtilities.Brief","page":"Brief","title":"TanayLabUtilities.Brief","text":"Functions for generating a brief description of arbitrary data. Yes, this is what the builtin summary is expected to do. However, summary doesn't summarize arrays that well. As we don't want to override it for types we don't own, we default brief to call summary and can then override it for whatever types we feel is necessary. For your own types, provide an implementation for summary as that is the \"right thing to do\".\n\n\n\n\n\n","category":"module"},{"location":"brief.html#TanayLabUtilities.Brief.brief","page":"Brief","title":"TanayLabUtilities.Brief.brief","text":"brief(value::Any)::AbstractString\n\nProvide a brief description of a value. This is basically summary but modified for specific types (in particular, vectors and matrices) to give \"better\" results.\n\nusing Test\n\n@test brief(1.0) == \"1.0\"\n@test brief(true) == \"true\"\n@test brief(:foo) == \":foo\"\n@test brief(nothing) == \"nothing\"\n@test brief(missing) == \"missing\"\n@test brief(undef) == \"undef\"\n@test brief((\"foo\", :bar)) == \"(\\\"foo\\\", :bar)\"\n@test brief(\"foo\" => :bar) == \"\\\"foo\\\" => :bar\"\n@test brief(\"foo\") == \"\\\"foo\\\"\"\n@test brief(\"foo \"^10) == \"\\\"foo foo foo foo ...\\\" (40)\"\n@test brief([true, false]) == \"2 x Bool (Dense; 50% true)\"\n@test brief(Int64) == \"Int64\"\n@test brief(String) == \"Str\"\n@test brief(AbstractString) == \"Str\"\n\n@enum Foo Bar Baz\n@test brief(Bar) == \"Foo::Bar\"\n\nstruct Vaz end\n@test brief(Vaz()) == summary(Vaz())\n\n@test brief(Set([1])) == \"1 x Int64 (Set)\"\n\n@test brief(rand(5)) == \"5 x Float64 (Dense)\"\n@test brief(rand(3, 4)) == \"3 x 4 x Float64 in Columns (Dense)\"\n\n@test brief(read_only_array(rand(5))) == \"5 x Float64 (ReadOnly, Dense)\"\n@test brief(PermutedDimsArray(rand(3, 4), (2, 1))) == \"4 x 3 x Float64 in Rows (Permute, Dense)\"\n@test brief(PermutedDimsArray(rand(3, 4), (1, 2))) == \"3 x 4 x Float64 in Columns (!Permute, Dense)\"\n\nusing SparseArrays\n\n@test brief(SparseVector([0.0, 1.0])) == \"2 x Float64 (Sparse Int64 50%)\"\n@test brief(SparseMatrixCSC([0.0 1.0 2.0; 3.0 4.0 0.0])) == \"2 x 3 x Float64 in Columns (Sparse Int64 67%)\"\n\nusing NamedArrays\n\n@test brief(NamedArray(rand(2))) == \"2 x Float64 (Named, Dense)\"\n@test brief(NamedArray(SparseVector([0.0, 1.0]))) == \"2 x Float64 (Named, Sparse Int64 50%)\"\n\nusing LinearAlgebra\n\n@test brief(transpose(rand(2))) == \"2 x Float64 (Transpose, Dense)\"\n@test brief(adjoint(rand(2))) == \"2 x Float64 (Adjoint, Dense)\"\n\n@test brief(Dict([\"a\" => 1])) == \"1 x Str => Int64 (Dict)\"\n\nprintln(\"OK\")\n\n# output\n\nOK\n\n\n\n\n\n","category":"function"},{"location":"brief.html#TanayLabUtilities.Brief.MAX_BRIEF_STRING","page":"Brief","title":"TanayLabUtilities.Brief.MAX_BRIEF_STRING","text":"The maximal length of strings we show as-is in brief. We only show a prefix of longer strings (followed by their length).\n\n\n\n\n\n","category":"constant"},{"location":"brief.html#TanayLabUtilities.Brief.percent","page":"Brief","title":"TanayLabUtilities.Brief.percent","text":"percent(used::Real, out_of::Real)::AbstractString\n\nFormat a fraction of used amount out_of some total, as an integer percent value. Very small fractions are denoted as <1% and very large fractions are denoted as >99%. We use this to show the percent of true values in masks, and the percent of non-zero entries in sparse arrays.\n\npercent(0, 0)\n\n# output\n\n\"NA%\"\n\npercent(0, 1000)\n\n# output\n\n\"0%\"\n\npercent(9, 1000)\n\n# output\n\n\"<1%\"\n\npercent(10, 1000)\n\n# output\n\n\"1%\"\n\npercent(11, 1000)\n\n# output\n\n\"1%\"\n\npercent(990, 1000)\n\n# output\n\n\"99%\"\n\npercent(991, 1000)\n\n# output\n\n\">99%\"\n\npercent(1000, 1000)\n\n# output\n\n\"100%\"\n\n\n\n\n\n","category":"function"},{"location":"brief.html#Index","page":"Brief","title":"Index","text":"","category":"section"},{"location":"brief.html","page":"Brief","title":"Brief","text":"Pages = [\"brief.md\"]","category":"page"},{"location":"logger.html#Logger","page":"Logger","title":"Logger","text":"","category":"section"},{"location":"logger.html","page":"Logger","title":"Logger","text":"TanayLabUtilities.Logger\nTanayLabUtilities.Logger.setup_logger\nTanayLabUtilities.Logger.@logged","category":"page"},{"location":"logger.html#TanayLabUtilities.Logger","page":"Logger","title":"TanayLabUtilities.Logger","text":"Setup a global logger the way we like it.\n\n\n\n\n\n","category":"module"},{"location":"logger.html#TanayLabUtilities.Logger.setup_logger","page":"Logger","title":"TanayLabUtilities.Logger.setup_logger","text":"setup_logger(\n    io::IO = stderr;\n    [level::LogLevel = Warn,\n    show_time::Bool = true,\n    show_module::Bool = true,\n    show_location::Bool = false]\n)::Nothing\n\nSetup a global logger that will print into io.\n\nBy default, this will only print warnings. Note that increasing the log level will apply to everything. An alternative is to set up the environment variable JULIA_DEBUG to a comma-separated list of modules you wish to see the debug messages of.\n\nIf show_time, each message will be prefixed with a yyyy-dd-mm HH:MM:SS.sss timestamp prefix.\n\nIf show_module, each message will be prefixed with the name of the module emitting the message.\n\nIf show_location, each message will be prefixed with the file name and the line number emitting the message.\n\nnote: Note\nWhen multi-processing is used, a P<id>: process index is added to the log entries. When multi-threading is used, a T<id>: thread index is added to the log entries, as well as a K<id>: task index. To generate the latter, this stores a unique :task_id index in the task_local_storage. This is important since a task may migrate between threads.\n\n\n\n\n\n","category":"function"},{"location":"logger.html#TanayLabUtilities.Logger.@logged","page":"Logger","title":"TanayLabUtilities.Logger.@logged","text":"@logged function something(...)\n    return ...\nend\n\nAutomatically log (in Debug level) every invocation to the function. This will also log the values of the arguments. Emits a second log entry when the function returns, with the result (if any).\n\n@logged function bar()::Nothing\n    return nothing\nend\n\n@logged function foo(positional; named = 1 + 2)\n    bar()\n    return positional + named\nend\n\nusing Logging\nusing Test\nlogger = TestLogger(; min_level = Logging.Debug)\nwith_logger(logger) do\n    return foo(1; named = 2)\nend\nprint(join([\"$(record.level) : $(record.message)\" for record in logger.logs], \"\n\"))\n\n# output\n\nDebug : foo {\nDebug : - positional: 1\nDebug : - named: 2\nDebug : bar {\nDebug : bar return }\nDebug : foo return: 3 }\n\n\n\n\n\n","category":"macro"},{"location":"logger.html#Index","page":"Logger","title":"Index","text":"","category":"section"},{"location":"logger.html","page":"Logger","title":"Logger","text":"Pages = [\"logger.md\"]","category":"page"},{"location":"documentation.html#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"TanayLabUtilities.Documentation\nTanayLabUtilities.Documentation.@documented\nTanayLabUtilities.Documentation.DEFAULT\nTanayLabUtilities.Documentation.function_default\nTanayLabUtilities.Documentation.@source_location","category":"page"},{"location":"documentation.html#TanayLabUtilities.Documentation","page":"Documentation","title":"TanayLabUtilities.Documentation","text":"Enhanced documentation for functions. This allows using the default values of function parameters as the basis for default values of other function parameters.\n\n\n\n\n\n","category":"module"},{"location":"documentation.html#TanayLabUtilities.Documentation.@documented","page":"Documentation","title":"TanayLabUtilities.Documentation.@documented","text":"@documented function something(...)\n    return ...\nend\n\nEnhance the documentation of a function. This stashes the default value of named arguments. This allows expanding DEFAULT in the documentation string, which is especially useful if these defaults are computed, read from global constants, copied from other functions via function_default, etc.\n\n\"Foo, default x: $(DEFAULT.x), default y: $(DEFAULT.y).\"\n@documented function foo(x::Integer = 1; y::Integer = 2)::Integer\n    return x + y\nend\n\n@assert foo() == 3\n@assert foo(2) == 4\nprintln(repr(\"text/markdown\", @doc foo))\n\n# output\n\nFoo, default x: `1`, default y: `2`.\n\n\"Foo, default x: $(DEFAULT.x).\"\n@documented function foo()::Integer\n    return 1\nend\n\nprintln(repr(\"text/markdown\", @doc foo))\n\n# output\n\nERROR: no parameter (with default): x\nexists for the function: foo\n\n\"Foo, default x: $(DEFAULT.x), default y: $(DEFAULT.y).\"\nfunction foo(x::Integer = 1; y::Integer = 2)::Integer\n    return x + y\nend\n\nprintln(repr(\"text/markdown\", @doc foo))\n\n# output\n\nERROR: not a @documented function: foo\n\n\n\n\n\n","category":"macro"},{"location":"documentation.html#TanayLabUtilities.Documentation.DEFAULT","page":"Documentation","title":"TanayLabUtilities.Documentation.DEFAULT","text":"When using @documented, then $(DEFAULT.x) will be expanded with the default value of the parameter x. It is good practice to contain a description of the effects of each parameter somewhere in the documentation, and it is polite to also provide its default value. This can be done in either the signature line or in the text, or both. Using DEFAULT ensures that the correct value is used in the documentation.\n\n\n\n\n\n","category":"constant"},{"location":"documentation.html#TanayLabUtilities.Documentation.function_default","page":"Documentation","title":"TanayLabUtilities.Documentation.function_default","text":"function_default(func::Function, parameter::Symbol)::Contract\n\nAccess the default of a parameter of a function annotated by @documented.\n\n@documented function foo(x::Integer = 1)::Nothing\n    return nothing\nend\n\nprintln(function_default(foo, :x))\nprintln(function_default(foo, :y))\n\n# output\n\n1\nERROR: no parameter (with default): y\nexists for the function: foo\n\nfunction foo(x::Integer = 1)::Nothing\n    return nothing\nend\n\nfunction_default(foo, :x)\n\n# output\n\nERROR: not a @documented function: foo\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#TanayLabUtilities.Documentation.@source_location","page":"Documentation","title":"TanayLabUtilities.Documentation.@source_location","text":"path, line = @source_location()\n\nReturn the path to the current source file and the current source line number.\n\n\n\n\n\n","category":"macro"},{"location":"documentation.html#Index","page":"Documentation","title":"Index","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Pages = [\"documentation.md\"]","category":"page"},{"location":"read_only_arrays.html#Read-Only-Arrays","page":"Read-Only Arrays","title":"Read-Only Arrays","text":"","category":"section"},{"location":"read_only_arrays.html","page":"Read-Only Arrays","title":"Read-Only Arrays","text":"TanayLabUtilities.ReadOnlyArrays\nTanayLabUtilities.ReadOnlyArrays.ReadOnlyArray\nTanayLabUtilities.ReadOnlyArrays.read_only_array\nTanayLabUtilities.ReadOnlyArrays.is_read_only_array\nTanayLabUtilities.ReadOnlyArrays.mutable_array","category":"page"},{"location":"read_only_arrays.html#TanayLabUtilities.ReadOnlyArrays","page":"Read-Only Arrays","title":"TanayLabUtilities.ReadOnlyArrays","text":"Read-only vectors and matrices, by ab/using SparseArrays.ReadOnly. We need this because we want access to shared data to be copy-free for efficiency (in particular, matrices can be several GBs). However, it would be very easy for the user code to access vector or matrix data and accidentally modify it in-place, thereby corrupting it and causing all sort of hard-to-debug hilarity. Julia in its infinite wisdom takes the view that \"everything is mutable\" so has no builtin notion of \"read-only view of an array\", probably due to the general weakness of its type system (which might be a price paid for efficient multiple dispatch?). Luckily the SparseArraysReadOnly package happens to implement something along these lines, which we shamelessly ab/use for our purposes and re-export as ReadOnlyArray.\n\nnote: Note\nThe read-only array functions below are restricted to dealing with normal (dense) arrays, SparseArrays, NamedArrays, PermutedDimsArray, and LinearAlgebra arrays (specifically, Transpose and Adjoint), as these are the types we actually use. YMMV if using more exotic matrix types. In theory you could extend the implementation to cover such types as well.\n\nWhen using \"wrapper\" array types, we try to push the \"read-only-ness\" as far down the stack of wrappers as possible. Thus applying this to a NamedArray, PermutedDimsArray, Transpose, Adjoint will wrap the parent of the array rather than the array itself. However SparseArrays have chosen to implement ReadOnly as a wrapper around SparseArray rather than as a wrapper for the internal data, presumably because it would have required them to separately wrap each of the internal arrays. IMVHO it would have been better if they went that way anyway and in general would have allowed for a wider range of array types for the internal arrays, as that would have allowed all sort of interesting features (e.g., a sparse array whose structure is fixed but only the non-zero values are mutable, a zero-copy sparse array whose data is a slice of a larger array, etc.). In general Julia's type hierarchy for arrays has some rough spots we need to deal with, partially because of the type system limitations, and partially because of some debatable decisions made when defining the core array types and conventions.\n\n\n\n\n\n","category":"module"},{"location":"read_only_arrays.html#TanayLabUtilities.ReadOnlyArrays.ReadOnlyArray","page":"Read-Only Arrays","title":"TanayLabUtilities.ReadOnlyArrays.ReadOnlyArray","text":"Just a rename (and re-export) of the internal ReadOnlyArray.\n\n\n\n\n\n","category":"type"},{"location":"read_only_arrays.html#TanayLabUtilities.ReadOnlyArrays.read_only_array","page":"Read-Only Arrays","title":"TanayLabUtilities.ReadOnlyArrays.read_only_array","text":"read_only_array(array::AbstractArray):AbstractArray\n\nAn immutable view of an array, using SparseArrays.ReadOnly. If the array is already immutable, it is returned as-is.\n\n# Base\n\nbase = [0 1 2; 3 4 0]\n@assert !is_read_only_array(base)\n\nread_only = read_only_array(base)\n@assert is_read_only_array(read_only)\n@assert read_only_array(read_only) === read_only\n\n# Named\n\nusing NamedArrays\n\nnamed = NamedArray(base)\n@assert !is_read_only_array(named)\n\nnamed_read_only = read_only_array(named)\n@assert named_read_only isa NamedArray\n@assert is_read_only_array(named_read_only)\n@assert read_only_array(named_read_only) === named_read_only\n\n# Permuted\n\npermuted = PermutedDimsArray(base, (2, 1))\n@assert !is_read_only_array(permuted)\n\npermuted_read_only = read_only_array(permuted)\n@assert permuted_read_only isa PermutedDimsArray\n@assert is_read_only_array(permuted_read_only)\n@assert read_only_array(permuted_read_only) === permuted_read_only\n\nunpermuted = PermutedDimsArray(base, (1, 2))\n@assert !is_read_only_array(unpermuted)\n\nunpermuted_read_only = read_only_array(unpermuted)\n@assert unpermuted_read_only isa PermutedDimsArray\n@assert is_read_only_array(unpermuted_read_only)\n@assert read_only_array(unpermuted_read_only) === unpermuted_read_only\n\n# LinearAlgebra\n\nusing LinearAlgebra\n\ntransposed = transpose(base)\n@assert !is_read_only_array(transposed)\n\ntransposed_read_only = read_only_array(transposed)\n@assert transposed_read_only isa Transpose\n@assert is_read_only_array(transposed_read_only)\n@assert read_only_array(transposed_read_only) === transposed_read_only\n\nadjointed = adjoint(base)\n@assert !is_read_only_array(adjointed)\n\nadjointed_read_only = read_only_array(adjointed)\n@assert adjointed_read_only isa Adjoint\n@assert is_read_only_array(adjointed_read_only)\n@assert read_only_array(adjointed_read_only) === adjointed_read_only\n\n# Sparse\n\nusing SparseArrays\n\nsparse = SparseMatrixCSC(base)\n@assert !is_read_only_array(sparse)\n\nsparse_read_only = read_only_array(sparse)\n@assert issparse(sparse_read_only)\n@assert is_read_only_array(sparse_read_only)\n@assert is_read_only_array(sparse_read_only)\n@assert read_only_array(sparse_read_only) === sparse_read_only\n\n# output\n\n\n\n\n\n","category":"function"},{"location":"read_only_arrays.html#TanayLabUtilities.ReadOnlyArrays.is_read_only_array","page":"Read-Only Arrays","title":"TanayLabUtilities.ReadOnlyArrays.is_read_only_array","text":"is_read_only_array(array::AbstractArray)::Bool\n\nReturn whether an array is immutable. See ReadOnlyArray\n\n\n\n\n\n","category":"function"},{"location":"read_only_arrays.html#TanayLabUtilities.ReadOnlyArrays.mutable_array","page":"Read-Only Arrays","title":"TanayLabUtilities.ReadOnlyArrays.mutable_array","text":"mutable_array(array::AbstractArray)::AbstractArray\n\nGrant mutable access to an array, even if it is a read-only array. If the array is already mutable, it is returned as-is.\n\nnote: Note\nThis should be used with great care because code depends on read-only arrays not changing their values.\n\nbase = [0 1 2; 3 4 0]\n\n@assert mutable_array(base) === base\n\nread_only = read_only_array(base)\n@assert mutable_array(read_only) === base\n\n# Named\n\nusing NamedArrays\n\nnamed = NamedArray(base)\n@assert !is_read_only_array(named)\n\n@assert mutable_array(named) === named\n@assert mutable_array(read_only_array(named)).array === named.array\n\n# Permuted\n\npermuted = PermutedDimsArray(base, (2, 1))\n\n@assert mutable_array(permuted) === permuted\n@assert mutable_array(read_only_array(permuted)) === permuted\n\nunpermuted = PermutedDimsArray(base, (1, 2))\n@assert !is_read_only_array(unpermuted)\n\n@assert mutable_array(unpermuted) === unpermuted\n@assert mutable_array(read_only_array(unpermuted)) === unpermuted\n\n# LinearAlgebra\n\nusing LinearAlgebra\n\ntransposed = transpose(base)\n@assert !is_read_only_array(transposed)\n\n@assert mutable_array(transposed) === transposed\n@assert mutable_array(read_only_array(transposed)) === transposed\n\nadjointed = adjoint(base)\n@assert !is_read_only_array(adjointed)\n\n@assert mutable_array(adjointed) === adjointed\n@assert mutable_array(read_only_array(adjointed)) === adjointed\n\n# Sparse\n\nusing SparseArrays\n\nsparse = SparseMatrixCSC(base)\n\n@assert mutable_array(sparse) === sparse\n@assert mutable_array(read_only_array(sparse)) === sparse\n\n# output\n\n\n\n\n\n","category":"function"},{"location":"read_only_arrays.html#Index","page":"Read-Only Arrays","title":"Index","text":"","category":"section"},{"location":"read_only_arrays.html","page":"Read-Only Arrays","title":"Read-Only Arrays","text":"Pages = [\"read_only_arrays.md\"]","category":"page"},{"location":"index.html#TanayLabUtilities","page":"TanayLabUtilities","title":"TanayLabUtilities","text":"","category":"section"},{"location":"index.html","page":"TanayLabUtilities","title":"TanayLabUtilities","text":"TanayLabUtilities.TanayLabUtilities","category":"page"},{"location":"index.html#TanayLabUtilities.TanayLabUtilities","page":"TanayLabUtilities","title":"TanayLabUtilities.TanayLabUtilities","text":"Generic utilities used by the Julia code for the Tanay lab.\n\nThis is a somewhat arbitrary collection of \"generally useful\" functions, created on an as-needed bases. No claim is made for true universality or for suitability for a particular purpose.\n\nIf you write using TanayLabUtilities everything will be exported into your global namespaces. Since this is a collection of loosely related functions, you may prefer to write using TanayLabUtilities.SomethingSpecific instead, or just import the specific symbol(s) you need.\n\nThe included modules are:\n\n(Image: )\n\n\n\n\n\n","category":"module"},{"location":"index.html#Index","page":"TanayLabUtilities","title":"Index","text":"","category":"section"},{"location":"index.html","page":"TanayLabUtilities","title":"TanayLabUtilities","text":"","category":"page"},{"location":"types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"TanayLabUtilities.Types\nTanayLabUtilities.Types.Maybe\nTanayLabUtilities.Types.Unsure","category":"page"},{"location":"types.html#TanayLabUtilities.Types","page":"Types","title":"TanayLabUtilities.Types","text":"(Very) generic types.\n\nWe got sick and tired of writing Union{..., Nothing} everywhere. We therefore created this shorthand unions listed below and used them throughout the code. We're well aware there was a religious war of whether there should be a standard shorthand for this, vs. a standard shorthand for Union{..., Missing}, with everyone losing, that is, having to use the explicit Union notation everywhere.\n\nLooking at the answers here then Nothing means \"there is no value\" and Missing means \"there is a value, but we don't know what it is\" (Unknown might have been a better name).\n\nUnder this interpretation, Union{..., Nothing} has (almost) the same semantics as Haskell's Maybe, so that's what we called it (other languages call this Optional or Opt). It is used heavily in our (and a lot of other) Julia code. We also added Unsure as a shorthand for Union{..., Missing} for completeness, but we do not actually use it anywhere. We assume it is useful for Julia code dealing specifically with statistical analysis.\n\n\n\n\n\n","category":"module"},{"location":"types.html#TanayLabUtilities.Types.Maybe","page":"Types","title":"TanayLabUtilities.Types.Maybe","text":"Maybe{T} = Union{T, Nothing}\n\nThe type to use when maybe there is a value, maybe there isn't. This is exactly as if writing the explicit Union with Nothing but is shorter and more readable. This is extremely common.\n\n\n\n\n\n","category":"type"},{"location":"types.html#TanayLabUtilities.Types.Unsure","page":"Types","title":"TanayLabUtilities.Types.Unsure","text":"Unsure{T} = Union{T, Missing}\n\nThe type to use when maybe there always is a value, but sometimes we are not sure what it is. This is exactly as if writing the explicit Union with Missing but is shorter and more readable. This is only used in code dealing with statistics to represent missing (that is, unknown) data. It is only provided here for completeness.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"}]
}
